From 7e8fad28d07d3a0ef04cf91608d73a1bf6199325 Mon Sep 17 00:00:00 2001
From: Alexandre Jutras <alexandre.jutras@nxp.com>
Date: Wed, 9 Oct 2019 16:31:48 -0400
Subject: [PATCH] [compositorclient] Implement a Wayland Weston abstraction

Signed-off-by: Alexandre Jutras <alexandre.jutras@nxp.com>
---
 Source/compositorclient/CMakeLists.txt             |    1 +
 Source/compositorclient/Wayland/CMakeLists.txt     |   11 +-
 Source/compositorclient/Wayland/Implementation.h   |   10 +
 Source/compositorclient/Wayland/Weston.cpp         | 1189 +++++++++++++
 .../xdg-shell-unstable-v6-client-protocol.h        | 1750 ++++++++++++++++++++
 cmake/modules/FindWestonClient.cmake               |   59 +
 6 files changed, 3017 insertions(+), 3 deletions(-)
 create mode 100644 Source/compositorclient/Wayland/Weston.cpp
 create mode 100644 Source/compositorclient/Wayland/xdg-shell-unstable-v6-client-protocol.h
 create mode 100644 cmake/modules/FindWestonClient.cmake

diff --git a/Source/compositorclient/CMakeLists.txt b/Source/compositorclient/CMakeLists.txt
index dcee173..07a76e1 100644
--- a/Source/compositorclient/CMakeLists.txt
+++ b/Source/compositorclient/CMakeLists.txt
@@ -1,6 +1,7 @@
 set(TARGET compositorclient)
 
 option(PLUGIN_COMPOSITOR_IMPLEMENTATION "Defines which implementation is used." "None")
+option(PLUGIN_COMPOSITOR_SUB_IMPLEMENTATION "Defines which sub-implementation is used." "None")
 
 message("Setup ${TARGET} v${VERSION}...")
 
diff --git a/Source/compositorclient/Wayland/CMakeLists.txt b/Source/compositorclient/Wayland/CMakeLists.txt
index 33add26..5ed8657 100644
--- a/Source/compositorclient/Wayland/CMakeLists.txt
+++ b/Source/compositorclient/Wayland/CMakeLists.txt
@@ -1,17 +1,22 @@
+if ((NOT "${PLUGIN_COMPOSITOR_SUB_IMPLEMENTATION}" STREQUAL "Weston") AND
+    (NOT "${PLUGIN_COMPOSITOR_SUB_IMPLEMENTATION}" STREQUAL "Westeros"))
+message( FATAL_ERROR "Invalid Wayland implementation, set PLUGIN_COMPOSITOR_SUB_IMPLEMENTATION to \"Weston\" or \"Westeros\"" )
+endif ()
+
 find_package(WaylandClient REQUIRED)
 find_package(EGL REQUIRED)
 find_package(WaylandEGL REQUIRED)
-find_package(WesterosClient REQUIRED)
+find_package(${PLUGIN_COMPOSITOR_SUB_IMPLEMENTATION}Client REQUIRED)
 find_package(NXCLIENT)
 
-add_library(${TARGET} SHARED Westeros.cpp)
+add_library(${TARGET} SHARED ${PLUGIN_COMPOSITOR_SUB_IMPLEMENTATION}.cpp)
 
 target_link_libraries(${TARGET}
     PRIVATE
         WaylandEGL::WaylandEGL
         ${EGL_LIBRARIES}
         ${NAMESPACE}Core::${NAMESPACE}Core
-        WesterosClient::WesterosClient
+        ${PLUGIN_COMPOSITOR_SUB_IMPLEMENTATION}Client::${PLUGIN_COMPOSITOR_SUB_IMPLEMENTATION}Client
         WaylandClient::WaylandClient)
 
 set_target_properties(${TARGET} PROPERTIES
diff --git a/Source/compositorclient/Wayland/Implementation.h b/Source/compositorclient/Wayland/Implementation.h
index 914ea11..89a96ab 100644
--- a/Source/compositorclient/Wayland/Implementation.h
+++ b/Source/compositorclient/Wayland/Implementation.h
@@ -25,6 +25,7 @@ struct wl_keyboard;
 struct wl_pointer;
 struct wl_touch;
 struct wl_simple_shell;
+struct zxdg_shell_v6;
 struct wl_shell;
 struct wl_surface;
 struct wl_egl_window;
@@ -33,6 +34,9 @@ struct wl_callback;
 struct wl_callback_listener;
 struct wl_shell_surface;
 
+struct zxdg_surface_v6;
+struct zxdg_toplevel_v6;
+
 namespace WPEFramework {
 namespace Wayland {
 
@@ -211,6 +215,11 @@ namespace Wayland {
             // of friend definitions.
             struct wl_surface* _surface;
 
+            struct zxdg_surface_v6 *_xdg_surface;
+            struct zxdg_toplevel_v6 *_xdg_toplevel;
+
+            bool _wait_for_configure;
+
         private:
             friend Display;
 
@@ -744,6 +753,7 @@ namespace Wayland {
         struct wl_pointer* _pointer;
         struct wl_touch* _touch;
         struct wl_shell* _shell;
+        struct zxdg_shell_v6* _xdg_shell;
 
         // KeyBoardInfo
         uint32_t _keyRate;
diff --git a/Source/compositorclient/Wayland/Weston.cpp b/Source/compositorclient/Wayland/Weston.cpp
new file mode 100644
index 0000000..74ebd04
--- /dev/null
+++ b/Source/compositorclient/Wayland/Weston.cpp
@@ -0,0 +1,1189 @@
+#include "Module.h"
+
+#define EGL_EGLEXT_PROTOTYPES 1
+
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+#include "../Client.h"
+#include "Implementation.h"
+
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+
+#include <wayland-client-core.h>
+#include <wayland-client.h>
+#include <wayland-egl.h>
+
+#include <poll.h>
+#include <pthread.h>
+#include <signal.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/signalfd.h>
+#include <unistd.h>
+
+#include "xdg-shell-unstable-v6-client-protocol.h"
+
+// logical xor
+#define XOR(a, b) ((!a && b) || (a && !b))
+
+using namespace WPEFramework;
+
+#define Trace(fmt, args...) fprintf(stderr, "[pid=%d][Client %s:%d] : " fmt, getpid(), __FILE__, __LINE__, ##args)
+
+#define RED_SIZE (8)
+#define GREEN_SIZE (8)
+#define BLUE_SIZE (8)
+#define ALPHA_SIZE (8)
+#define DEPTH_SIZE (0)
+
+static const struct wl_shell_surface_listener g_ShellSurfaceListener = {
+    //handle_ping,
+    [](void* data, struct wl_shell_surface* shell_surface, uint32_t serial) {
+        wl_shell_surface_pong(shell_surface, serial);
+    },
+    //handle_configure,
+    [](void* data, struct wl_shell_surface* shell_surface, uint32_t edges, int32_t width, int32_t height) {
+        Trace("handle_configure: width=%d height=%d \n", width, height);
+        //  Wayland::Display::Sur *wayland = static_cast<Wayland *>(data);
+        // wl_egl_window_resize(wayland->eglWindow, width, height, 0, 0);
+    },
+    //handle_popup_done
+    [](void* data, struct wl_shell_surface* shell_surface) {
+    }
+};
+
+struct wl_shm_listener shmListener = {
+    // shmFormat
+    [](void* data, struct wl_shm* wl_shm, uint32_t format) {
+        Trace("shm format: %X\n", format);
+    }
+};
+
+static const struct wl_output_listener outputListener = {
+    // outputGeometry
+    [](void* data, struct wl_output* output, int32_t x, int32_t y, int32_t physical_width, int32_t physical_height, int32_t subpixel, const char* make, const char* model, int32_t transform) {
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+        Trace("wl_output_listener.outputGeometry x=%d y=%d physical_width=%d physical_height=%d, make=%s: model=%s transform=%d subpixel%d\n",
+            x, y, physical_width, physical_height, make, model, transform, subpixel);
+        Wayland::Display::Rectangle& rect(const_cast<Wayland::Display::Rectangle&>(context.Physical()));
+        rect.X = x;
+        rect.Y = y;
+        rect.Width = physical_width;
+        rect.Height = physical_height;
+    },
+    // outputMode
+    [](void* data, struct wl_output* output, uint32_t flags, int32_t width, int32_t height, int32_t refresh) {
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+
+        const Wayland::Display::Rectangle& rect(context.Physical());
+
+        if ((flags & WL_OUTPUT_MODE_CURRENT) && ((width != rect.Width) || (height != rect.Height))) {
+            Wayland::Display::Rectangle& rect(const_cast<Wayland::Display::Rectangle&>(context.Physical()));
+            rect.Width = width;
+            rect.Height = height;
+            Trace("wl_output_listener.outputMode [0,0,%d,%d]\n", width, height);
+        }
+    },
+    // outputDone
+    [](void* data, struct wl_output* output) {
+    },
+    // outputScale
+    [](void* data, struct wl_output* output, int32_t factor) {
+    }
+};
+
+static const struct wl_keyboard_listener keyboardListener = {
+    // keyboardKeymap
+    [](void* data, struct wl_keyboard* keyboard, uint32_t format, int32_t fd, uint32_t size) {
+        if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1) {
+            close(fd);
+        } else {
+            void* mapping = ::mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0);
+            if (mapping == MAP_FAILED) {
+                close(fd);
+            } else {
+
+                Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+                context.KeyMapConfiguration(static_cast<const char*>(mapping), size);
+                munmap(mapping, size);
+                close(fd);
+            }
+        }
+        Trace("wl_keyboard_listener.keyboardKeymap [%d,%d]\n", format, size);
+    },
+    // keyboardEnter,
+    [](void* data, struct wl_keyboard* keyboard, uint32_t serial, struct wl_surface* surface, struct wl_array* keys) {
+        Trace("wl_keyboard_listener.keyboardEnter serial=%d\n", serial);
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+        context.FocusKeyboard(surface, true);
+    },
+    // keyboardLeave,
+    [](void* data, struct wl_keyboard* keyboard, uint32_t serial, struct wl_surface* surface) {
+        Trace("wl_keyboard_listener.keyboardLeave serial=%d\n", serial);
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+        context.FocusKeyboard(surface, false);
+    },
+    // keyboardKey
+    [](void* data, struct wl_keyboard* keyboard, uint32_t serial, uint32_t time, uint32_t key, uint32_t state) {
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+
+        // Have no idea if this is true, just lets see...
+        assert(keyboard == context._keyboard);
+
+        Wayland::Display::IKeyboard::state action;
+        switch (state) {
+        case WL_KEYBOARD_KEY_STATE_RELEASED:
+            action = Wayland::Display::IKeyboard::released;
+            break;
+        case WL_KEYBOARD_KEY_STATE_PRESSED:
+            action = Wayland::Display::IKeyboard::pressed;
+            break;
+        default:
+            action = static_cast<Wayland::Display::IKeyboard::state>(state);
+        }
+        context.Key(key, action, time);
+
+        Trace("wl_keyboard_listener.keyboardKey [0x%02X, %s, 0x%02X ]\n", key, state == WL_KEYBOARD_KEY_STATE_PRESSED ? "Pressed" : "Released", context._keyModifiers);
+    },
+    // keyboardModifiers
+    [](void* data, struct wl_keyboard* keyboard, uint32_t serial, uint32_t mods_depressed, uint32_t mods_latched, uint32_t mods_locked, uint32_t group) {
+        Trace("wl_keyboard_listener.keyboardModifiers [%d,%d,%d]\n", mods_depressed, mods_latched, mods_locked);
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+        context.Modifiers(mods_depressed, mods_latched, mods_locked, group);
+    },
+    // keyboardRepeatInfo
+    [](void* data, struct wl_keyboard* keyboard, int32_t rate, int32_t delay) {
+        Trace("wl_keyboard_listener.keyboardRepeatInfo [%d,%d]\n", rate, delay);
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+        context.Repeat(rate, delay);
+    }
+};
+
+static const struct wl_pointer_listener pointerListener = {
+    // pointerEnter
+    [](void* data, struct wl_pointer* pointer, uint32_t serial, struct wl_surface* surface, wl_fixed_t sx, wl_fixed_t sy) {
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+        int x, y;
+
+        x = wl_fixed_to_int(sx);
+        y = wl_fixed_to_int(sy);
+
+        Trace("wl_pointer_listener.pointerEnter [%d,%d]\n", x, y);
+        context.FocusPointer(surface, true);
+    },
+    // pointerLeave
+    [](void* data, struct wl_pointer* pointer, uint32_t serial, struct wl_surface* surface) {
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+        Trace("wl_pointer_listener.pointerLeave [%p]\n", surface);
+        context.FocusPointer(surface, false);
+    },
+    // pointerMotion
+    [](void* data, struct wl_pointer* pointer, uint32_t time, wl_fixed_t sx, wl_fixed_t sy) {
+        int x, y;
+
+        x = wl_fixed_to_int(sx);
+        y = wl_fixed_to_int(sy);
+
+        Trace("wl_pointer_listener.pointerMotion [%d,%d]\n", x, y);
+    },
+    // pointerButton
+    [](void* data, struct wl_pointer* pointer, uint32_t serial, uint32_t time, uint32_t button, uint32_t state) {
+        Trace("wl_pointer_listener.pointerButton [%u,%u]\n", button, state);
+    },
+    // pointerAxis
+    [](void* data, struct wl_pointer* pointer, uint32_t time, uint32_t axis, wl_fixed_t value) {
+        int v;
+        v = wl_fixed_to_int(value);
+        Trace("wl_pointer_listener.pointerAxis [%u,%d]\n", axis, v);
+    }
+};
+
+static const struct wl_seat_listener seatListener = {
+    // seatCapabilities,
+    [](void* data, struct wl_seat* seat, uint32_t capabilities) {
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+
+        Trace("wl_seat_listener.seatCapabilities [%p,%d]\n", seat, capabilities);
+
+        if (capabilities & WL_SEAT_CAPABILITY_KEYBOARD) {
+            context._keyboard = wl_seat_get_keyboard(context._seat);
+            wl_keyboard_add_listener(context._keyboard, &keyboardListener, data);
+            Trace("wl_seat_listener.keyboard [%p,%p]\n", seat, context._keyboard);
+        }
+        if (capabilities & WL_SEAT_CAPABILITY_POINTER) {
+            context._pointer = wl_seat_get_pointer(context._seat);
+            wl_pointer_add_listener(context._pointer, &pointerListener, data);
+            Trace("wl_seat_listener.pointer [%p,%p]\n", seat, context._pointer);
+        }
+        if (capabilities & WL_SEAT_CAPABILITY_TOUCH) {
+            context._touch = wl_seat_get_touch(context._seat);
+            Trace("wl_seat_listener.touch [%p,%p]\n", seat, context._touch);
+        }
+    },
+    // seatName
+    [](void* data, struct wl_seat* seat, const char* name) {
+        Trace("wl_seat_listener.seatName[%p,%s]\n", seat, name);
+    }
+};
+
+static void
+xdg_shell_ping(void *data, struct zxdg_shell_v6 *shell, uint32_t serial)
+{
+    zxdg_shell_v6_pong(shell, serial);
+}
+
+static const struct zxdg_shell_v6_listener xdg_shell_listener = {
+    xdg_shell_ping,
+};
+
+static const struct wl_registry_listener globalRegistryListener = {
+
+    // global
+    [](void* data, struct wl_registry* registry, uint32_t name, const char* interface, uint32_t version) {
+        Trace("wl_registry_listener.global interface=%s name=%d version=%d\n", interface, name, version);
+
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+
+        if (::strcmp(interface, "wl_compositor") == 0) {
+            // I expect that a compositor is tied to a display, so expect the name here to be the one of the display.
+            // Lets check :-)
+            context._compositor = static_cast<struct wl_compositor*>(wl_registry_bind(registry, name, &wl_compositor_interface, 1));
+        } 
+        else if (::strcmp(interface, "wl_seat") == 0) {
+            // A shell, is probably associated with a client, so I guess we now need to find a client..
+            struct wl_seat* result = static_cast<struct wl_seat*>(wl_registry_bind(registry, name, &wl_seat_interface, 4));
+            wl_seat_add_listener(result, &seatListener, data);
+            context._seat = result;
+        } else if (::strcmp(interface, "wl_shell") == 0) {
+            // A shell, is probably associated with a client, so I guess we now need to find a client..
+            context._shell = static_cast<struct wl_shell*>(wl_registry_bind(registry, name, &wl_shell_interface, 1));
+        } else if (::strcmp(interface, "wl_output") == 0) {
+            struct wl_output* result = static_cast<struct wl_output*>(wl_registry_bind(registry, name, &wl_output_interface, 2));
+            wl_output_add_listener(result, &outputListener, data);
+            context._output = result;
+        } else if (strcmp(interface, "zxdg_shell_v6") == 0) {
+            struct zxdg_shell_v6* result = static_cast<struct zxdg_shell_v6*>(wl_registry_bind(registry, name, &zxdg_shell_v6_interface, 1));
+                    
+            zxdg_shell_v6_add_listener(result, &xdg_shell_listener, data);
+            context._xdg_shell = result;
+        }
+    },
+    // global_remove
+    [](void*, struct wl_registry*, uint32_t) {
+        Trace("wl_registry_listener.global_remove\n");
+    },
+};
+
+static void
+handle_surface_configure(void *data, struct zxdg_surface_v6 *surface,
+             uint32_t serial)
+{
+    zxdg_surface_v6_ack_configure(surface, serial);
+}
+
+static const struct zxdg_surface_v6_listener xdg_surface_listener = {
+    handle_surface_configure
+};
+
+
+static void
+handle_toplevel_configure(void *data, struct zxdg_toplevel_v6 *toplevel,
+              int32_t width, int32_t height,
+              struct wl_array *states)
+{
+    // TODO
+    // Wayland::Display *display = (Wayland::Display *)data;
+    // display->Dimensions(id, 1, 0, 0, width, height, 1, 0);
+}
+
+static void
+handle_toplevel_close(void *data, struct zxdg_toplevel_v6 *xdg_toplevel)
+{
+    //running = 0;
+}
+
+static const struct zxdg_toplevel_v6_listener xdg_toplevel_listener = {
+    handle_toplevel_configure,
+    handle_toplevel_close
+};
+
+namespace WPEFramework {
+
+namespace Wayland {
+    /*static*/ Display::CriticalSection Display::_adminLock;
+    /*static*/ std::string Display::_runtimeDir;
+    /*static*/ Display::DisplayMap Display::_displays;
+    /*static*/ Display::WaylandSurfaceMap Display::_waylandSurfaces;
+
+    static void printEGLConfiguration(EGLDisplay dpy, EGLConfig config)
+    {
+#define X(VAL)    \
+    {             \
+        VAL, #VAL \
+    }
+        struct {
+            EGLint attribute;
+            const char* name;
+        } names[] = {
+            X(EGL_BUFFER_SIZE),
+            X(EGL_RED_SIZE),
+            X(EGL_GREEN_SIZE),
+            X(EGL_BLUE_SIZE),
+            X(EGL_ALPHA_SIZE),
+            X(EGL_CONFIG_CAVEAT),
+            X(EGL_CONFIG_ID),
+            X(EGL_DEPTH_SIZE),
+            X(EGL_LEVEL),
+            X(EGL_MAX_PBUFFER_WIDTH),
+            X(EGL_MAX_PBUFFER_HEIGHT),
+            X(EGL_MAX_PBUFFER_PIXELS),
+            X(EGL_NATIVE_RENDERABLE),
+            X(EGL_NATIVE_VISUAL_ID),
+            X(EGL_NATIVE_VISUAL_TYPE),
+            X(EGL_SAMPLE_BUFFERS),
+            X(EGL_SAMPLES),
+            X(EGL_SURFACE_TYPE),
+            X(EGL_TRANSPARENT_TYPE),
+        };
+#undef X
+
+        Trace("Config details:\n");
+        for (unsigned int j = 0; j < sizeof(names) / sizeof(names[0]); j++) {
+            EGLint value = -1;
+            EGLBoolean res = eglGetConfigAttrib(dpy, config, names[j].attribute, &value);
+            if (res) {
+                Trace("  - %s: %d (0x%x)\n", names[j].name, value, value);
+            }
+        }
+    }
+
+    Display::SurfaceImplementation::SurfaceImplementation(Display& display, const std::string& name, const uint32_t width, const uint32_t height)
+        : _surface(nullptr)
+        , _refcount(1)
+        , _level(0)
+        , _name(name)
+        , _id(0)
+        , _x(0)
+        , _y(0)
+        , _width(width)
+        , _height(height)
+        , _visible(0)
+        , _opacity(0)
+        , _ZOrder(0)
+        , _display(&display)
+        , _native(nullptr)
+        , _frameCallback(nullptr)
+        , _eglSurfaceWindow(EGL_NO_SURFACE)
+        , _keyboard(nullptr)
+        , _pointer(nullptr)
+        , _upScale(false)
+    {
+        assert(display.IsOperational());
+
+        _level = 0;
+
+        _surface = wl_compositor_create_surface(display._compositor);
+
+        if (_surface != nullptr) {
+
+            struct wl_region* region;
+            region = wl_compositor_create_region(display._compositor);
+
+            wl_region_add(region, 0, 0, width, height);
+
+            // Found in WPEwayland implementation:
+            wl_surface_set_opaque_region(_surface, region);
+
+            wl_region_destroy(region);
+
+            Trace("Creating a surface of size: %d x %d\n", width, height);
+
+            _native = wl_egl_window_create(_surface, width, height);
+
+            assert(EGL_NO_SURFACE != _native);
+
+            if (_display->HasEGLContext() == true) {
+                Connect(EGLSurface(EGL_NO_SURFACE));
+            }
+        }
+    }
+
+    Display::SurfaceImplementation::SurfaceImplementation(Display& display, const uint32_t id, struct wl_surface* surface)
+        : _surface(surface)
+        , _refcount(1)
+        , _level(2)
+        , _name()
+        , _id(id)
+        , _width(0)
+        , _height(0)
+        , _visible(0)
+        , _opacity(0)
+        , _ZOrder(0)
+        , _display(&display)
+        , _native(nullptr)
+        , _frameCallback(nullptr)
+        , _shellSurface(nullptr)
+        , _eglSurfaceWindow(EGL_NO_SURFACE)
+        , _keyboard(nullptr)
+        , _pointer(nullptr)
+        , _upScale(false)
+    {
+    }
+
+    Display::SurfaceImplementation::SurfaceImplementation(Display& display, const uint32_t id, const char* name)
+        : _surface(nullptr)
+        , _refcount(1)
+        , _level(2)
+        , _name(name)
+        , _id(id)
+        , _width(0)
+        , _height(0)
+        , _visible(0)
+        , _opacity(0)
+        , _ZOrder(0)
+        , _display(&display)
+        , _native(nullptr)
+        , _frameCallback(nullptr)
+        , _shellSurface(nullptr)
+        , _eglSurfaceWindow(EGL_NO_SURFACE)
+        , _keyboard(nullptr)
+        , _pointer(nullptr)
+        , _upScale(false)
+    {
+    }
+
+    void Display::SurfaceImplementation::Callback(wl_callback_listener* listener, void* data)
+    {
+
+        assert((listener == nullptr) ^ (_frameCallback == nullptr));
+
+        if (listener != nullptr) {
+
+            _frameCallback = wl_surface_frame(_surface);
+            wl_callback_add_listener(_frameCallback, listener, data);
+
+            eglSwapBuffers(_display->_eglDisplay, _eglSurfaceWindow);
+        } else {
+            wl_callback_destroy(_frameCallback);
+            _frameCallback = nullptr;
+        }
+    }
+
+    void Display::SurfaceImplementation::Resize(const int dx, const int dy, const int width, const int height)
+    {
+        Trace("WARNING: Display::SurfaceImplementation::Resize is not implemented\n");
+    }
+
+    void Display::SurfaceImplementation::Visibility(const bool visible)
+    {
+        Trace("WARNING: Display::SurfaceImplementation::Visibility is not implemented\n");
+    }
+
+    void Display::SurfaceImplementation::Opacity(const uint32_t opacity)
+    {
+        Trace("WARNING: Display::SurfaceImplementation::Opacity is not implemented\n");
+    }
+
+    void Display::SurfaceImplementation::ZOrder(const uint32_t order)
+    {
+        Trace("WARNING: Display::SurfaceImplementation::ZOrder is not implemented\n");
+    }
+
+    void Display::SurfaceImplementation::BringToFront()
+    {
+        Trace("WARNING: Display::SurfaceImplementation::BringToFront is not implemented\n");
+    }
+
+    void Display::SurfaceImplementation::SetTop()
+    {
+        Trace("WARNING: Display::SurfaceImplementation::SetTop is not implemented\n");
+    }
+
+    void Display::SurfaceImplementation::Dimensions(
+        const uint32_t visible,
+        const int32_t x, const int32_t y, const int32_t width, const int32_t height,
+        const uint32_t opacity,
+        const uint32_t zorder)
+    {
+        Trace("Updated surfaceId=%d width=%d  height=%d x=%d, y=%d visible=%d opacity=%d zorder=%d\n", _id, width, height, x, y, visible, opacity, zorder);
+
+        _visible = visible;
+        _opacity = opacity;
+        _ZOrder = zorder;
+        // This is the response form the status, but if we created the window, we need to check
+        // and set according to the request.
+        if (_native != nullptr) {
+            if ((_width != width) || (_height != height) || (_x != x) || (_y != y)) {
+                Trace("Resizing surface %d from [%d x %d] to [%d x %d]\n", _id, _width, _height, width, height);
+                wl_egl_window_resize(_native, _width, _height, x, y);
+            }
+        } else {
+            // Update this surface
+            Trace("Update surface %d from [%d x %d] to [%d x %d]\n", _id, _width, _height, width, height);
+            _x = x;
+            _y = y;
+            _width = width;
+            _height = height;
+        }
+
+        wl_display_flush(_display->_display);
+
+        Trace("Current surfaceId=%d width=%d  height=%d x=%d, y=%d, visible=%d opacity=%d zorder=%d\n", _id, _width, _height, _x, _y, _visible, _opacity, _ZOrder);
+    }
+
+    void Display::SurfaceImplementation::Redraw()
+    {
+        _display->Trigger();
+
+        // wait for wayland to flush events
+        sem_wait(&(_display->_redraw));
+        if (_native != nullptr) {
+            eglSwapBuffers(_display->_eglDisplay, _eglSurfaceWindow);
+        }
+    }
+
+    void Display::SurfaceImplementation::Unlink()
+    {
+        if (_display != nullptr) {
+
+            if (_frameCallback != nullptr) {
+                wl_callback_destroy(_frameCallback);
+            }
+
+            if (_eglSurfaceWindow != EGL_NO_SURFACE) {
+
+                eglDestroySurface(_display->_eglDisplay, _eglSurfaceWindow);
+                _eglSurfaceWindow = EGL_NO_SURFACE;
+            }
+
+            if (_native != nullptr) {
+                wl_egl_window_destroy(_native);
+                _native = nullptr;
+            }
+
+            if (_shellSurface != nullptr) {
+                wl_shell_surface_destroy(_shellSurface);
+                _shellSurface = nullptr;
+            }
+
+            if (_surface != nullptr) {
+                wl_surface_destroy(_surface);
+                _surface = nullptr;
+            }
+
+            _display = nullptr;
+        }
+    }
+
+    bool Display::SurfaceImplementation::Connect(const EGLSurface& surface)
+    {
+        if (surface != EGL_NO_SURFACE) {
+            _eglSurfaceWindow = surface;
+        } else {
+            if (_display->_eglContext == EGL_NO_CONTEXT) {
+                _display->InitializeEGL();
+            }
+
+            if (_display->_eglContext != EGL_NO_CONTEXT) {
+                /*
+                 * Create a window surface
+                 */
+                _eglSurfaceWindow = eglCreateWindowSurface(
+                    _display->_eglDisplay,
+                    _display->_eglConfig,
+                    reinterpret_cast<EGLNativeWindowType>(_native),
+                    nullptr);
+
+                if (_eglSurfaceWindow == EGL_NO_SURFACE) {
+
+                    _eglSurfaceWindow = eglCreateWindowSurface(
+                        _display->_eglDisplay,
+                        _display->_eglConfig,
+                        static_cast<EGLNativeWindowType>(nullptr),
+                        nullptr);
+                }
+
+                assert(EGL_NO_SURFACE != _eglSurfaceWindow);
+
+                EGLint height(0);
+                EGLint width(0);
+                eglQuerySurface(_display->_eglDisplay, _eglSurfaceWindow, EGL_WIDTH, &width);
+                eglQuerySurface(_display->_eglDisplay, _eglSurfaceWindow, EGL_HEIGHT, &height);
+
+                Trace("EGL window surface is %dx%d\n", height, width);
+            }
+        }
+
+        if (_eglSurfaceWindow != EGL_NO_SURFACE) {
+            /*
+             * Establish EGL context for this thread
+             */
+
+            int result = eglMakeCurrent(_display->_eglDisplay, _eglSurfaceWindow, _eglSurfaceWindow, _display->_eglContext);
+            assert(EGL_FALSE != result);
+
+            if (EGL_FALSE != result) {
+                result = eglSwapInterval(_display->_eglDisplay, 1);
+                assert(EGL_FALSE != result);
+            }
+        }
+
+        return (_eglSurfaceWindow != EGL_NO_SURFACE);
+    }
+
+    Display::ImageImplementation::ImageImplementation(Display& display, const uint32_t texture, const uint32_t width, const uint32_t height)
+        : _refcount(1)
+        , _display(&display)
+    {
+        _eglImageKHR = eglCreateImageKHR(_display->_eglDisplay, _display->_eglContext, EGL_GL_TEXTURE_2D_KHR,
+            reinterpret_cast<EGLClientBuffer>(texture), 0);
+    }
+
+    Display::ImageImplementation::~ImageImplementation()
+    {
+        if (_display != nullptr) {
+            eglDestroyImageKHR(_display->_eglDisplay, _eglImageKHR);
+        }
+    }
+
+    static void* Processor(void* data)
+    {
+        Wayland::Display& context = *(static_cast<Wayland::Display*>(data));
+
+        while ((sem_wait(&context._trigger) == 0) && (context._display != nullptr)) {
+            Trace("Flush Events\n");
+            wl_display_flush(context._display);
+
+            context.Redraw();
+        }
+        return nullptr;
+    }
+    Display::~Display()
+    {
+        ASSERT(_refCount == 0);
+        DisplayMap::iterator index(_displays.find(_displayName));
+
+        if (index != _displays.end()) {
+            _displays.erase(index);
+        }
+#ifdef BCM_HOST
+        bcm_host_deinit();
+#endif
+    }
+
+
+    void Display::Initialize()
+    {
+        Trace("Display::Initialize\n");
+        if (_display != nullptr)
+            return;
+
+        if (_runtimeDir.empty() == true) {
+            const char* envName = ::getenv("XDG_RUNTIME_DIR");
+            if (envName != nullptr) {
+                _runtimeDir = envName;
+            }
+        }
+
+        Trace("Initialize Wayland Display on %s\n", _runtimeDir.c_str());
+        Trace("Initialize Wayland Display Name %s\n", _displayName.c_str());
+        if (_displayId.empty() == false)
+            Trace("Connecting to Wayland Display %s\n", _displayId.c_str());
+
+        _display = wl_display_connect(_displayId.empty() == false ? _displayId.c_str() : nullptr);
+
+        assert(_display != nullptr);
+
+        if (_display != nullptr) {
+            _registry = wl_display_get_registry(_display);
+
+            assert(_registry != nullptr);
+
+            if (_registry != nullptr) {
+
+                wl_registry_add_listener(_registry, &globalRegistryListener, this);
+                wl_display_roundtrip(_display);
+
+                sem_init(&_trigger, 0, 0);
+                sem_init(&_redraw, 0, 0);
+
+                Trace("creating communication thread\n");
+                if (pthread_create(&_tid, nullptr, Processor, this) != 0) {
+                    Trace("[Wayland] Error creating communication thread\n");
+                }
+            }
+        }
+    }
+
+    void Display::InitializeEGL()
+    {
+        /*
+         * Get default EGL display
+         */
+        _eglDisplay = eglGetDisplay(reinterpret_cast<NativeDisplayType>(_display));
+
+        Trace("Display: %p\n", _eglDisplay);
+
+        if (_eglDisplay == EGL_NO_DISPLAY) {
+            Trace("Oops bad Display: %p\n", _eglDisplay);
+        } else {
+            /*
+             * Initialize display
+             */
+            EGLint major, minor;
+            if (eglInitialize(_eglDisplay, &major, &minor) != EGL_TRUE) {
+                Trace("Unable to initialize EGL: %X\n", eglGetError());
+            } else {
+                /*
+                 * Get number of available configurations
+                 */
+                EGLint configCount;
+                Trace("Vendor: %s\n", eglQueryString(_eglDisplay, EGL_VENDOR));
+                Trace("Version: %d.%d\n", major, minor);
+
+                if (eglGetConfigs(_eglDisplay, nullptr, 0, &configCount)) {
+
+                    EGLConfig eglConfigs[configCount];
+
+                    EGLint attributes[] = {
+                        EGL_RED_SIZE, RED_SIZE,
+                        EGL_GREEN_SIZE, GREEN_SIZE,
+                        EGL_BLUE_SIZE, BLUE_SIZE,
+                        EGL_DEPTH_SIZE, DEPTH_SIZE,
+                        EGL_STENCIL_SIZE, 0,
+                        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+                        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+                        EGL_NONE
+                    };
+
+                    Trace("Configs: %d\n", configCount);
+                    /*
+                     * Get a list of configurations that meet or exceed our requirements
+                     */
+                    if (eglChooseConfig(_eglDisplay, attributes, eglConfigs, configCount, &configCount)) {
+
+                        /*
+                         * Choose a suitable configuration
+                         */
+                        int index = 0;
+
+                        while (index < configCount) {
+                            EGLint redSize, greenSize, blueSize, alphaSize, depthSize;
+
+                            eglGetConfigAttrib(_eglDisplay, eglConfigs[index], EGL_RED_SIZE, &redSize);
+                            eglGetConfigAttrib(_eglDisplay, eglConfigs[index], EGL_GREEN_SIZE, &greenSize);
+                            eglGetConfigAttrib(_eglDisplay, eglConfigs[index], EGL_BLUE_SIZE, &blueSize);
+                            eglGetConfigAttrib(_eglDisplay, eglConfigs[index], EGL_ALPHA_SIZE, &alphaSize);
+                            eglGetConfigAttrib(_eglDisplay, eglConfigs[index], EGL_DEPTH_SIZE, &depthSize);
+
+                            if ((redSize == RED_SIZE) && (greenSize == GREEN_SIZE) && (blueSize == BLUE_SIZE) && (alphaSize == ALPHA_SIZE) && (depthSize >= DEPTH_SIZE)) {
+                                break;
+                            }
+
+                            index++;
+                        }
+                        if (index < configCount) {
+                            _eglConfig = eglConfigs[index];
+
+                            EGLint attributes[] = { EGL_CONTEXT_CLIENT_VERSION, 2 /* ES2 */, EGL_NONE };
+
+                            Trace("Config choosen: %d\n", index);
+                            printEGLConfiguration(_eglDisplay, _eglConfig);
+
+                            /*
+                             * Create an EGL context
+                             */
+                            _eglContext = eglCreateContext(_eglDisplay, _eglConfig, EGL_NO_CONTEXT, attributes);
+
+                            Trace("Context created\n");
+                        }
+                    }
+                }
+                Trace("Extentions: %s\n", eglQueryString(_eglDisplay, EGL_EXTENSIONS));
+            }
+        }
+    }
+
+    void Display::Deinitialize()
+    {
+        Trace("Display::Deinitialize\n");
+
+        _adminLock.Lock();
+
+        _keyboardReceiver = nullptr;
+
+        // First notify our client of our destruction...
+        SurfaceMap::iterator index(_surfaces.begin());
+
+        while (index != _surfaces.end()) {
+            // Remove the entry from global list
+            WaylandSurfaceMap::iterator entry(_waylandSurfaces.find(index->second->_surface));
+
+            if (entry != _waylandSurfaces.end()) {
+                entry->second->Release();
+                _waylandSurfaces.erase(entry);
+            }
+
+            index->second->Unlink();
+            index->second->Release();
+            index++;
+        }
+
+        WaylandSurfaceMap::iterator entry(_waylandSurfaces.begin());
+
+        while (entry != _waylandSurfaces.end()) {
+
+            entry->second->Release();
+            entry++;
+        }
+
+        _waylandSurfaces.clear();
+        _surfaces.clear();
+
+        if (_eglContext != EGL_NO_CONTEXT) {
+            eglMakeCurrent(_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+            eglTerminate(_eglDisplay);
+            eglReleaseThread();
+        }
+        if (_output != nullptr) {
+            wl_output_destroy(_output);
+            _output = nullptr;
+        }
+
+        if (_xdg_shell != nullptr) {
+            zxdg_shell_v6_destroy(_xdg_shell);
+            _xdg_shell = nullptr;
+        }
+
+        if (_shell != nullptr) {
+            wl_shell_destroy(_shell);
+            _shell = nullptr;
+        }
+
+        if (_seat != nullptr) {
+            wl_seat_destroy(_seat);
+            _seat = nullptr;
+        }
+
+        if (_keyboard) {
+            wl_keyboard_destroy(_keyboard);
+            _keyboard = nullptr;
+        }
+
+        if (_compositor != nullptr) {
+            wl_compositor_destroy(_compositor);
+            _compositor = nullptr;
+        }
+
+        if (_registry != nullptr) {
+            wl_registry_destroy(_registry);
+            _registry = nullptr;
+        }
+        if (_display != nullptr) {
+            wl_display_disconnect(_display);
+            _display = nullptr;
+        }
+        _adminLock.Unlock();
+
+        Trigger();
+
+        pthread_join(_tid, nullptr);
+    }
+
+    void Display::LoadSurfaces()
+    {
+        Trace("Display::LoadSurfaces\n");
+
+        _collect |= true; 
+    }
+
+
+    Compositor::IDisplay::ISurface* Display::Create(const std::string& name, const uint32_t width, const uint32_t height)
+    {
+        IDisplay::ISurface* result = nullptr;
+
+        Trace("Display::Create\n");
+
+        _adminLock.Lock();
+
+        SurfaceImplementation* surface = new SurfaceImplementation(*this, name, width, height);
+
+        if(_xdg_shell != nullptr) {
+            surface->_xdg_surface = zxdg_shell_v6_get_xdg_surface(_xdg_shell, surface->_surface);
+            assert(surface->_xdg_surface != NULL);
+            zxdg_surface_v6_add_listener(surface->_xdg_surface, &xdg_surface_listener, this);
+
+            surface->_xdg_toplevel = zxdg_surface_v6_get_toplevel(surface->_xdg_surface);
+            assert(surface->_xdg_toplevel != NULL);
+            zxdg_toplevel_v6_add_listener(surface->_xdg_toplevel, &xdg_toplevel_listener, this);
+
+            zxdg_toplevel_v6_set_title(surface->_xdg_toplevel, "compositor_client");
+
+            surface->_wait_for_configure = true;
+            wl_surface_commit(surface->_surface);
+
+            zxdg_toplevel_v6_set_fullscreen(surface->_xdg_toplevel, NULL);
+        }
+
+        // Wait till we are fully registered.
+        _waylandSurfaces.insert(std::pair<struct wl_surface*, SurfaceImplementation*>(surface->_surface, surface));
+
+        result = surface;
+
+        _adminLock.Unlock();
+
+        return (result);
+    }
+
+    Display::Image Display::Create(const uint32_t texture, const uint32_t width, const uint32_t height)
+    {
+        Trace("Display::Create (with texture)\n");
+
+        return (Image(*new ImageImplementation(*this, texture, width, height)));
+    }
+
+    void Display::Constructed(const uint32_t id, wl_surface* surface)
+    {
+        Trace("Display::Constructed (with surface)\n");
+
+        _adminLock.Lock();
+
+        WaylandSurfaceMap::iterator index = _waylandSurfaces.find(surface);
+
+        if (index != _waylandSurfaces.end()) {
+            zxdg_toplevel_v6_set_title(index->second->_xdg_toplevel, index->second->Name().c_str());
+
+            // Do not forget to update the actual surface, it is now alive..
+            index->second->_id = id;
+            index->second->AddRef();
+            _surfaces.insert(std::pair<uint32_t, Display::SurfaceImplementation*>(id, index->second));
+        } else if (_collect == true) {
+            // Seems this is a surface, we did not create.
+            Display::SurfaceImplementation* entry(new Display::SurfaceImplementation(*this, id, surface));
+            entry->AddRef();
+            _surfaces.insert(std::pair<uint32_t, Display::SurfaceImplementation*>(id, entry));
+            _waylandSurfaces.insert(std::pair<wl_surface*, Display::SurfaceImplementation*>(surface, entry));
+        }
+
+        if (_clientHandler != nullptr) {
+            _clientHandler->Attached(id);
+        }
+
+        _adminLock.Unlock();
+    }
+
+    void Display::Constructed(const uint32_t id, const char* name)
+    {
+        Trace("Constructed (with name)\n");
+        _adminLock.Lock();
+
+        SurfaceMap::iterator index = _surfaces.find(id);
+
+        if (index != _surfaces.end()) {
+            index->second->Name(name);
+        }
+
+        if (_collect == true) {
+            Display::SurfaceImplementation* entry = new Display::SurfaceImplementation(*this, id, name);
+
+            // manual increase the refcount for the _waylandSurfaces map.
+            entry->AddRef();
+
+            // Somewhere, someone, created a surface, register it.
+            _surfaces.insert(std::pair<uint32_t, Display::SurfaceImplementation*>(id, entry));
+        }
+
+        if (_clientHandler != nullptr) {
+            _clientHandler->Attached(id);
+        }
+        _adminLock.Unlock();
+    }
+
+    void Display::Dimensions(
+        const uint32_t id,
+        const uint32_t visible,
+        const int32_t x, const int32_t y, const int32_t width, const int32_t height,
+        const uint32_t opacity,
+        const uint32_t zorder)
+    {
+        Trace("Updated Dimensions surfaceId=%d width=%d  height=%d x=%d, y=%d visible=%d opacity=%d zorder=%d\n", id, width, height, x, y, visible, opacity, zorder);
+        _adminLock.Lock();
+
+        SurfaceMap::iterator index = _surfaces.find(id);
+
+        if (index != _surfaces.end()) {
+            Trace("Updated Dimensions surfaceId=%d name=%s width=%d  height=%d x=%d, y=%d visible=%d opacity=%d zorder=%d\n", id, index->second->Name().c_str(), width, height, x, y, visible, opacity, zorder);
+            index->second->Dimensions(visible, x, y, width, height, opacity, zorder);
+        } else {
+            // TODO: Seems this is a surface, we did not create. maybe we need to collect it in future.
+            //Trace("Unidentified surface: id=%d.\n");
+        }
+
+        _adminLock.Unlock();
+    }
+
+    void Display::Destructed(const uint32_t id)
+    {
+        Trace("Display::Destructed\n");
+
+        _adminLock.Lock();
+
+        if (_collect != true) {
+            SurfaceMap::iterator index = _surfaces.find(id);
+
+            if (index != _surfaces.end()) {
+                // See if it is in the surfaces map, we need to take it out here as well..
+                WaylandSurfaceMap::iterator entry(_waylandSurfaces.find(index->second->_surface));
+
+                // assert(entry != _waylandSurfaces.end());
+
+                if (entry != _waylandSurfaces.end()) {
+                    entry->second->Release();
+                    _waylandSurfaces.erase(entry);
+                }
+
+                if (_keyboardReceiver == index->second) {
+                    _keyboardReceiver = nullptr;
+                }
+
+                index->second->Unlink();
+                index->second->Release();
+                _surfaces.erase(index);
+            }
+
+        }
+        if (_clientHandler != nullptr) {
+            _clientHandler->Detached(id);
+        }
+        _adminLock.Unlock();
+    }
+
+    /* static */ Display& Display::Instance(const std::string& displayName)
+    {
+        if (_runtimeDir.empty() == true) {
+            const char* envName = ::getenv("XDG_RUNTIME_DIR");
+            if (envName != nullptr) {
+                _runtimeDir = envName;
+            }
+        }
+
+        // Please define a runtime directory, or using an environment variable (XDG_RUNTIME_DIR)
+        // or by setting it before creating a Display, using Display::RuntimeDirectory(<DIR>),
+        // or by passing it as an argument to this method (none empty dir)
+        assert(_runtimeDir.empty() == false);
+
+        Display* result(nullptr);
+
+        _adminLock.Lock();
+
+        DisplayMap::iterator index(_displays.find(displayName));
+
+        if (index == _displays.end()) {
+            result = new Display(displayName);
+            _displays.insert(std::pair<const std::string, Display*>(displayName, result));
+        } else {
+            result = index->second;
+        }
+        result->AddRef();
+        _adminLock.Unlock();
+
+        assert(result != nullptr);
+
+        return (*result);
+    }
+
+    static void signalHandler(int signum)
+    {
+    }
+
+    void Display::Process(Display::IProcess* processloop)
+    {
+
+        struct sigaction sigint;
+
+        sigint.sa_handler = signalHandler;
+        sigemptyset(&sigint.sa_mask);
+        sigint.sa_flags = SA_RESETHAND;
+        sigaction(SIGINT, &sigint, nullptr);
+
+        _thread = ::pthread_self();
+
+        Trace("Setup dispatch loop using thread %p signal: %d \n", &_thread, _signal);
+        if (_display != nullptr) {
+            while ((wl_display_dispatch(_display) != -1) && (processloop->Dispatch() == true)) {
+                /* intentionally left empty */
+            }
+        }
+    }
+
+    int Display::Process(const uint32_t data)
+    {
+
+        signed int result(0);
+        _adminLock.Lock();
+        if (_display) {
+
+            while (wl_display_prepare_read(_display) != 0) {
+                if (wl_display_dispatch_pending(_display) < 0) {
+                    result = -1;
+                    break;
+                }
+            }
+
+            wl_display_flush(_display);
+
+            if (data != 0) {
+                if (wl_display_read_events(_display) < 0) {
+                    result = -2;
+                } else {
+                    if (wl_display_dispatch_pending(_display) < 0) {
+                        result = 1;
+                    }
+                }
+            } else {
+                wl_display_cancel_read(_display);
+                result = -3;
+            }
+        }
+        _adminLock.Unlock();
+        return result;
+    }
+
+    void Display::AddRef() const
+    {
+        if (Core::InterlockedIncrement(_refCount) == 1) {
+            const_cast<Display*>(this)->Initialize();
+        }
+        return;
+    }
+
+    uint32_t Display::Release() const
+    {
+        if (Core::InterlockedDecrement(_refCount) == 0) {
+            const_cast<Display*>(this)->Deinitialize();
+
+            //Indicate Wayland connection is closed properly
+            return (Core::ERROR_CONNECTION_CLOSED);
+        }
+        return (Core::ERROR_NONE);
+    }
+
+    int Display::FileDescriptor() const
+    {
+        return (wl_display_get_fd(_display));
+    }
+
+    void Display::Signal()
+    {
+        printf("Received Signal, killing thread %p.\n", &_thread);
+        ::pthread_kill(_thread, SIGINT);
+    }
+}
+
+/* static */ Compositor::IDisplay* Compositor::IDisplay::Instance(const std::string& displayName)
+{
+    return (&(Wayland::Display::Instance(displayName)));
+}
+}
diff --git a/Source/compositorclient/Wayland/xdg-shell-unstable-v6-client-protocol.h b/Source/compositorclient/Wayland/xdg-shell-unstable-v6-client-protocol.h
new file mode 100644
index 0000000..8e741f5
--- /dev/null
+++ b/Source/compositorclient/Wayland/xdg-shell-unstable-v6-client-protocol.h
@@ -0,0 +1,1750 @@
+/* Generated by wayland-scanner 1.16.0 */
+
+#ifndef XDG_SHELL_UNSTABLE_V6_CLIENT_PROTOCOL_H
+#define XDG_SHELL_UNSTABLE_V6_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_xdg_shell_unstable_v6 The xdg_shell_unstable_v6 protocol
+ * @section page_ifaces_xdg_shell_unstable_v6 Interfaces
+ * - @subpage page_iface_zxdg_shell_v6 - create desktop-style surfaces
+ * - @subpage page_iface_zxdg_positioner_v6 - child surface positioner
+ * - @subpage page_iface_zxdg_surface_v6 - desktop user interface surface base interface
+ * - @subpage page_iface_zxdg_toplevel_v6 - toplevel surface
+ * - @subpage page_iface_zxdg_popup_v6 - short-lived, popup surfaces for menus
+ * @section page_copyright_xdg_shell_unstable_v6 Copyright
+ * <pre>
+ *
+ * Copyright © 2008-2013 Kristian Høgsberg
+ * Copyright © 2013      Rafael Antognolli
+ * Copyright © 2013      Jasper St. Pierre
+ * Copyright © 2010-2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_output;
+struct wl_seat;
+struct wl_surface;
+struct zxdg_popup_v6;
+struct zxdg_positioner_v6;
+struct zxdg_shell_v6;
+struct zxdg_surface_v6;
+struct zxdg_toplevel_v6;
+
+/**
+ * @page page_iface_zxdg_shell_v6 zxdg_shell_v6
+ * @section page_iface_zxdg_shell_v6_desc Description
+ *
+ * xdg_shell allows clients to turn a wl_surface into a "real window"
+ * which can be dragged, resized, stacked, and moved around by the
+ * user. Everything about this interface is suited towards traditional
+ * desktop environments.
+ * @section page_iface_zxdg_shell_v6_api API
+ * See @ref iface_zxdg_shell_v6.
+ */
+/**
+ * @defgroup iface_zxdg_shell_v6 The zxdg_shell_v6 interface
+ *
+ * xdg_shell allows clients to turn a wl_surface into a "real window"
+ * which can be dragged, resized, stacked, and moved around by the
+ * user. Everything about this interface is suited towards traditional
+ * desktop environments.
+ */
+extern const struct wl_interface zxdg_shell_v6_interface;
+/**
+ * @page page_iface_zxdg_positioner_v6 zxdg_positioner_v6
+ * @section page_iface_zxdg_positioner_v6_desc Description
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle. These positioner-created rules are
+ * constrained by the requirement that a child surface must intersect with or
+ * be at least partially adjacent to its parent surface.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an error.
+ * @section page_iface_zxdg_positioner_v6_api API
+ * See @ref iface_zxdg_positioner_v6.
+ */
+/**
+ * @defgroup iface_zxdg_positioner_v6 The zxdg_positioner_v6 interface
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle. These positioner-created rules are
+ * constrained by the requirement that a child surface must intersect with or
+ * be at least partially adjacent to its parent surface.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an error.
+ */
+extern const struct wl_interface zxdg_positioner_v6_interface;
+/**
+ * @page page_iface_zxdg_surface_v6 zxdg_surface_v6
+ * @section page_iface_zxdg_surface_v6_desc Description
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * For a surface to be mapped by the compositor, the following conditions
+ * must be met: (1) the client has assigned a xdg_surface based role to the
+ * surface, (2) the client has set and committed the xdg_surface state and
+ * the role dependent state to the surface and (3) the client has committed a
+ * buffer to the surface.
+ * @section page_iface_zxdg_surface_v6_api API
+ * See @ref iface_zxdg_surface_v6.
+ */
+/**
+ * @defgroup iface_zxdg_surface_v6 The zxdg_surface_v6 interface
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * For a surface to be mapped by the compositor, the following conditions
+ * must be met: (1) the client has assigned a xdg_surface based role to the
+ * surface, (2) the client has set and committed the xdg_surface state and
+ * the role dependent state to the surface and (3) the client has committed a
+ * buffer to the surface.
+ */
+extern const struct wl_interface zxdg_surface_v6_interface;
+/**
+ * @page page_iface_zxdg_toplevel_v6 zxdg_toplevel_v6
+ * @section page_iface_zxdg_toplevel_v6_desc Description
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ * @section page_iface_zxdg_toplevel_v6_api API
+ * See @ref iface_zxdg_toplevel_v6.
+ */
+/**
+ * @defgroup iface_zxdg_toplevel_v6 The zxdg_toplevel_v6 interface
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ */
+extern const struct wl_interface zxdg_toplevel_v6_interface;
+/**
+ * @page page_iface_zxdg_popup_v6 zxdg_popup_v6
+ * @section page_iface_zxdg_popup_v6_desc Description
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * The parent surface must have either the xdg_toplevel or xdg_popup surface
+ * role.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The x and y arguments passed when creating the popup object specify
+ * where the top left of the popup should be placed, relative to the
+ * local surface coordinates of the parent surface. See
+ * xdg_surface.get_popup. An xdg_popup must intersect with or be at least
+ * partially adjacent to its parent surface.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ * @section page_iface_zxdg_popup_v6_api API
+ * See @ref iface_zxdg_popup_v6.
+ */
+/**
+ * @defgroup iface_zxdg_popup_v6 The zxdg_popup_v6 interface
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * The parent surface must have either the xdg_toplevel or xdg_popup surface
+ * role.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The x and y arguments passed when creating the popup object specify
+ * where the top left of the popup should be placed, relative to the
+ * local surface coordinates of the parent surface. See
+ * xdg_surface.get_popup. An xdg_popup must intersect with or be at least
+ * partially adjacent to its parent surface.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ */
+extern const struct wl_interface zxdg_popup_v6_interface;
+
+#ifndef ZXDG_SHELL_V6_ERROR_ENUM
+#define ZXDG_SHELL_V6_ERROR_ENUM
+enum zxdg_shell_v6_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	ZXDG_SHELL_V6_ERROR_ROLE = 0,
+	/**
+	 * xdg_shell was destroyed before children
+	 */
+	ZXDG_SHELL_V6_ERROR_DEFUNCT_SURFACES = 1,
+	/**
+	 * the client tried to map or destroy a non-topmost popup
+	 */
+	ZXDG_SHELL_V6_ERROR_NOT_THE_TOPMOST_POPUP = 2,
+	/**
+	 * the client specified an invalid popup parent surface
+	 */
+	ZXDG_SHELL_V6_ERROR_INVALID_POPUP_PARENT = 3,
+	/**
+	 * the client provided an invalid surface state
+	 */
+	ZXDG_SHELL_V6_ERROR_INVALID_SURFACE_STATE = 4,
+	/**
+	 * the client provided an invalid positioner
+	 */
+	ZXDG_SHELL_V6_ERROR_INVALID_POSITIONER = 5,
+};
+#endif /* ZXDG_SHELL_V6_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ * @struct zxdg_shell_v6_listener
+ */
+struct zxdg_shell_v6_listener {
+	/**
+	 * check if the client is alive
+	 *
+	 * The ping event asks the client if it's still alive. Pass the
+	 * serial specified in the event back to the compositor by sending
+	 * a "pong" request back with the specified serial. See
+	 * xdg_shell.ping.
+	 *
+	 * Compositors can use this to determine if the client is still
+	 * alive. It's unspecified what will happen if the client doesn't
+	 * respond to the ping request, or in what timeframe. Clients
+	 * should try to respond in a reasonable amount of time.
+	 *
+	 * A compositor is free to ping in any way it wants, but a client
+	 * must always respond to any xdg_shell object it created.
+	 * @param serial pass this to the pong request
+	 */
+	void (*ping)(void *data,
+		     struct zxdg_shell_v6 *zxdg_shell_v6,
+		     uint32_t serial);
+};
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+static inline int
+zxdg_shell_v6_add_listener(struct zxdg_shell_v6 *zxdg_shell_v6,
+			   const struct zxdg_shell_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_shell_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_SHELL_V6_DESTROY 0
+#define ZXDG_SHELL_V6_CREATE_POSITIONER 1
+#define ZXDG_SHELL_V6_GET_XDG_SURFACE 2
+#define ZXDG_SHELL_V6_PONG 3
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_PING_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_CREATE_POSITIONER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_GET_XDG_SURFACE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_shell_v6
+ */
+#define ZXDG_SHELL_V6_PONG_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_shell_v6 */
+static inline void
+zxdg_shell_v6_set_user_data(struct zxdg_shell_v6 *zxdg_shell_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_shell_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_shell_v6 */
+static inline void *
+zxdg_shell_v6_get_user_data(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_shell_v6);
+}
+
+static inline uint32_t
+zxdg_shell_v6_get_version(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_shell_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * Destroy this xdg_shell object.
+ *
+ * Destroying a bound xdg_shell object while there are surfaces
+ * still alive created by this xdg_shell object instance is illegal
+ * and will result in a protocol error.
+ */
+static inline void
+zxdg_shell_v6_destroy(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_shell_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * Create a positioner object. A positioner object is used to position
+ * surfaces relative to some parent surface. See the interface description
+ * and xdg_surface.get_popup for details.
+ */
+static inline struct zxdg_positioner_v6 *
+zxdg_shell_v6_create_positioner(struct zxdg_shell_v6 *zxdg_shell_v6)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_CREATE_POSITIONER, &zxdg_positioner_v6_interface, NULL);
+
+	return (struct zxdg_positioner_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * This creates an xdg_surface for the given surface. While xdg_surface
+ * itself is not a role, the corresponding surface may only be assigned
+ * a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
+ *
+ * This creates an xdg_surface for the given surface. An xdg_surface is
+ * used as basis to define a role to a given surface, such as xdg_toplevel
+ * or xdg_popup. It also manages functionality shared between xdg_surface
+ * based surface roles.
+ *
+ * See the documentation of xdg_surface for more details about what an
+ * xdg_surface is and how it is used.
+ */
+static inline struct zxdg_surface_v6 *
+zxdg_shell_v6_get_xdg_surface(struct zxdg_shell_v6 *zxdg_shell_v6, struct wl_surface *surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_GET_XDG_SURFACE, &zxdg_surface_v6_interface, NULL, surface);
+
+	return (struct zxdg_surface_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_shell_v6
+ *
+ * A client must respond to a ping event with a pong request or
+ * the client may be deemed unresponsive. See xdg_shell.ping.
+ */
+static inline void
+zxdg_shell_v6_pong(struct zxdg_shell_v6 *zxdg_shell_v6, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_shell_v6,
+			 ZXDG_SHELL_V6_PONG, serial);
+}
+
+#ifndef ZXDG_POSITIONER_V6_ERROR_ENUM
+#define ZXDG_POSITIONER_V6_ERROR_ENUM
+enum zxdg_positioner_v6_error {
+	/**
+	 * invalid input provided
+	 */
+	ZXDG_POSITIONER_V6_ERROR_INVALID_INPUT = 0,
+};
+#endif /* ZXDG_POSITIONER_V6_ERROR_ENUM */
+
+#ifndef ZXDG_POSITIONER_V6_ANCHOR_ENUM
+#define ZXDG_POSITIONER_V6_ANCHOR_ENUM
+enum zxdg_positioner_v6_anchor {
+	/**
+	 * the center of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_NONE = 0,
+	/**
+	 * the top edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_TOP = 1,
+	/**
+	 * the bottom edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_BOTTOM = 2,
+	/**
+	 * the left edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_LEFT = 4,
+	/**
+	 * the right edge of the anchor rectangle
+	 */
+	ZXDG_POSITIONER_V6_ANCHOR_RIGHT = 8,
+};
+#endif /* ZXDG_POSITIONER_V6_ANCHOR_ENUM */
+
+#ifndef ZXDG_POSITIONER_V6_GRAVITY_ENUM
+#define ZXDG_POSITIONER_V6_GRAVITY_ENUM
+enum zxdg_positioner_v6_gravity {
+	/**
+	 * center over the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_NONE = 0,
+	/**
+	 * position above the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_TOP = 1,
+	/**
+	 * position below the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_BOTTOM = 2,
+	/**
+	 * position to the left of the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_LEFT = 4,
+	/**
+	 * position to the right of the anchor edge
+	 */
+	ZXDG_POSITIONER_V6_GRAVITY_RIGHT = 8,
+};
+#endif /* ZXDG_POSITIONER_V6_GRAVITY_ENUM */
+
+#ifndef ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_ENUM
+#define ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_ENUM
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ * vertically resize the surface
+ *
+ * Resize the surface vertically so that it is completely unconstrained.
+ */
+enum zxdg_positioner_v6_constraint_adjustment {
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_NONE = 0,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_FLIP_X = 4,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16,
+	ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32,
+};
+#endif /* ZXDG_POSITIONER_V6_CONSTRAINT_ADJUSTMENT_ENUM */
+
+#define ZXDG_POSITIONER_V6_DESTROY 0
+#define ZXDG_POSITIONER_V6_SET_SIZE 1
+#define ZXDG_POSITIONER_V6_SET_ANCHOR_RECT 2
+#define ZXDG_POSITIONER_V6_SET_ANCHOR 3
+#define ZXDG_POSITIONER_V6_SET_GRAVITY 4
+#define ZXDG_POSITIONER_V6_SET_CONSTRAINT_ADJUSTMENT 5
+#define ZXDG_POSITIONER_V6_SET_OFFSET 6
+
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_ANCHOR_RECT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_ANCHOR_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_GRAVITY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ */
+#define ZXDG_POSITIONER_V6_SET_OFFSET_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_positioner_v6 */
+static inline void
+zxdg_positioner_v6_set_user_data(struct zxdg_positioner_v6 *zxdg_positioner_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_positioner_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_positioner_v6 */
+static inline void *
+zxdg_positioner_v6_get_user_data(struct zxdg_positioner_v6 *zxdg_positioner_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_positioner_v6);
+}
+
+static inline uint32_t
+zxdg_positioner_v6_get_version(struct zxdg_positioner_v6 *zxdg_positioner_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_positioner_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Notify the compositor that the xdg_positioner will no longer be used.
+ */
+static inline void
+zxdg_positioner_v6_destroy(struct zxdg_positioner_v6 *zxdg_positioner_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_positioner_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Set the size of the surface that is to be positioned with the positioner
+ * object. The size is in surface-local coordinates and corresponds to the
+ * window geometry. See xdg_surface.set_window_geometry.
+ *
+ * If a zero or negative size is set the invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_size(struct zxdg_positioner_v6 *zxdg_positioner_v6, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Specify the anchor rectangle within the parent surface that the child
+ * surface will be placed relative to. The rectangle is relative to the
+ * window geometry as defined by xdg_surface.set_window_geometry of the
+ * parent surface. The rectangle must be at least 1x1 large.
+ *
+ * When the xdg_positioner object is used to position a child surface, the
+ * anchor rectangle may not extend outside the window geometry of the
+ * positioned child's parent surface.
+ *
+ * If a zero or negative size is set the invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_anchor_rect(struct zxdg_positioner_v6 *zxdg_positioner_v6, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_ANCHOR_RECT, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Defines a set of edges for the anchor rectangle. These are used to
+ * derive an anchor point that the child surface will be positioned
+ * relative to. If two orthogonal edges are specified (e.g. 'top' and
+ * 'left'), then the anchor point will be the intersection of the edges
+ * (e.g. the top left position of the rectangle); otherwise, the derived
+ * anchor point will be centered on the specified edge, or in the center of
+ * the anchor rectangle if no edge is specified.
+ *
+ * If two parallel anchor edges are specified (e.g. 'left' and 'right'),
+ * the invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_anchor(struct zxdg_positioner_v6 *zxdg_positioner_v6, uint32_t anchor)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_ANCHOR, anchor);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Defines in what direction a surface should be positioned, relative to
+ * the anchor point of the parent surface. If two orthogonal gravities are
+ * specified (e.g. 'bottom' and 'right'), then the child surface will be
+ * placed in the specified direction; otherwise, the child surface will be
+ * centered over the anchor point on any axis that had no gravity
+ * specified.
+ *
+ * If two parallel gravities are specified (e.g. 'left' and 'right'), the
+ * invalid_input error is raised.
+ */
+static inline void
+zxdg_positioner_v6_set_gravity(struct zxdg_positioner_v6 *zxdg_positioner_v6, uint32_t gravity)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_GRAVITY, gravity);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Specify how the window should be positioned if the originally intended
+ * position caused the surface to be constrained, meaning at least
+ * partially outside positioning boundaries set by the compositor. The
+ * adjustment is set by constructing a bitmask describing the adjustment to
+ * be made when the surface is constrained on that axis.
+ *
+ * If no bit for one axis is set, the compositor will assume that the child
+ * surface should not change its position on that axis when constrained.
+ *
+ * If more than one bit for one axis is set, the order of how adjustments
+ * are applied is specified in the corresponding adjustment descriptions.
+ *
+ * The default adjustment is none.
+ */
+static inline void
+zxdg_positioner_v6_set_constraint_adjustment(struct zxdg_positioner_v6 *zxdg_positioner_v6, uint32_t constraint_adjustment)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_CONSTRAINT_ADJUSTMENT, constraint_adjustment);
+}
+
+/**
+ * @ingroup iface_zxdg_positioner_v6
+ *
+ * Specify the surface position offset relative to the position of the
+ * anchor on the anchor rectangle and the anchor on the surface. For
+ * example if the anchor of the anchor rectangle is at (x, y), the surface
+ * has the gravity bottom|right, and the offset is (ox, oy), the calculated
+ * surface position will be (x + ox, y + oy). The offset position of the
+ * surface is the one used for constraint testing. See
+ * set_constraint_adjustment.
+ *
+ * An example use case is placing a popup menu on top of a user interface
+ * element, while aligning the user interface element of the parent surface
+ * with some user interface element placed somewhere in the popup surface.
+ */
+static inline void
+zxdg_positioner_v6_set_offset(struct zxdg_positioner_v6 *zxdg_positioner_v6, int32_t x, int32_t y)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_positioner_v6,
+			 ZXDG_POSITIONER_V6_SET_OFFSET, x, y);
+}
+
+#ifndef ZXDG_SURFACE_V6_ERROR_ENUM
+#define ZXDG_SURFACE_V6_ERROR_ENUM
+enum zxdg_surface_v6_error {
+	ZXDG_SURFACE_V6_ERROR_NOT_CONSTRUCTED = 1,
+	ZXDG_SURFACE_V6_ERROR_ALREADY_CONSTRUCTED = 2,
+	ZXDG_SURFACE_V6_ERROR_UNCONFIGURED_BUFFER = 3,
+};
+#endif /* ZXDG_SURFACE_V6_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ * @struct zxdg_surface_v6_listener
+ */
+struct zxdg_surface_v6_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * The configure event marks the end of a configure sequence. A
+	 * configure sequence is a set of one or more events configuring
+	 * the state of the xdg_surface, including the final
+	 * xdg_surface.configure event.
+	 *
+	 * Where applicable, xdg_surface surface roles will during a
+	 * configure sequence extend this event as a latched state sent as
+	 * events before the xdg_surface.configure event. Such events
+	 * should be considered to make up a set of atomically applied
+	 * configuration states, where the xdg_surface.configure commits
+	 * the accumulated state.
+	 *
+	 * Clients should arrange their surface for the new states, and
+	 * then send an ack_configure request with the serial sent in this
+	 * configure event at some point before committing the new surface.
+	 *
+	 * If the client receives multiple configure events before it can
+	 * respond to one, it is free to discard all but the last event it
+	 * received.
+	 * @param serial serial of the configure event
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_surface_v6 *zxdg_surface_v6,
+			  uint32_t serial);
+};
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+static inline int
+zxdg_surface_v6_add_listener(struct zxdg_surface_v6 *zxdg_surface_v6,
+			     const struct zxdg_surface_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_surface_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_SURFACE_V6_DESTROY 0
+#define ZXDG_SURFACE_V6_GET_TOPLEVEL 1
+#define ZXDG_SURFACE_V6_GET_POPUP 2
+#define ZXDG_SURFACE_V6_SET_WINDOW_GEOMETRY 3
+#define ZXDG_SURFACE_V6_ACK_CONFIGURE 4
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_GET_TOPLEVEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_GET_POPUP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_SET_WINDOW_GEOMETRY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_surface_v6
+ */
+#define ZXDG_SURFACE_V6_ACK_CONFIGURE_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_surface_v6 */
+static inline void
+zxdg_surface_v6_set_user_data(struct zxdg_surface_v6 *zxdg_surface_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_surface_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_surface_v6 */
+static inline void *
+zxdg_surface_v6_get_user_data(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_surface_v6);
+}
+
+static inline uint32_t
+zxdg_surface_v6_get_version(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_surface_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * Destroy the xdg_surface object. An xdg_surface must only be destroyed
+ * after its role object has been destroyed.
+ */
+static inline void
+zxdg_surface_v6_destroy(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_surface_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * This creates an xdg_toplevel object for the given xdg_surface and gives
+ * the associated wl_surface the xdg_toplevel role.
+ *
+ * See the documentation of xdg_toplevel for more details about what an
+ * xdg_toplevel is and how it is used.
+ */
+static inline struct zxdg_toplevel_v6 *
+zxdg_surface_v6_get_toplevel(struct zxdg_surface_v6 *zxdg_surface_v6)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_GET_TOPLEVEL, &zxdg_toplevel_v6_interface, NULL);
+
+	return (struct zxdg_toplevel_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * This creates an xdg_popup object for the given xdg_surface and gives the
+ * associated wl_surface the xdg_popup role.
+ *
+ * See the documentation of xdg_popup for more details about what an
+ * xdg_popup is and how it is used.
+ */
+static inline struct zxdg_popup_v6 *
+zxdg_surface_v6_get_popup(struct zxdg_surface_v6 *zxdg_surface_v6, struct zxdg_surface_v6 *parent, struct zxdg_positioner_v6 *positioner)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_GET_POPUP, &zxdg_popup_v6_interface, NULL, parent, positioner);
+
+	return (struct zxdg_popup_v6 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * The window geometry of a surface is its "visible bounds" from the
+ * user's perspective. Client-side decorations often have invisible
+ * portions like drop-shadows which should be ignored for the
+ * purposes of aligning, placing and constraining windows.
+ *
+ * The window geometry is double buffered, and will be applied at the
+ * time wl_surface.commit of the corresponding wl_surface is called.
+ *
+ * Once the window geometry of the surface is set, it is not possible to
+ * unset it, and it will remain the same until set_window_geometry is
+ * called again, even if a new subsurface or buffer is attached.
+ *
+ * If never set, the value is the full bounds of the surface,
+ * including any subsurfaces. This updates dynamically on every
+ * commit. This unset is meant for extremely simple clients.
+ *
+ * The arguments are given in the surface-local coordinate space of
+ * the wl_surface associated with this xdg_surface.
+ *
+ * The width and height must be greater than zero. Setting an invalid size
+ * will raise an error. When applied, the effective window geometry will be
+ * the set window geometry clamped to the bounding rectangle of the
+ * combined geometry of the surface of the xdg_surface and the associated
+ * subsurfaces.
+ */
+static inline void
+zxdg_surface_v6_set_window_geometry(struct zxdg_surface_v6 *zxdg_surface_v6, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_SET_WINDOW_GEOMETRY, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_surface_v6
+ *
+ * When a configure event is received, if a client commits the
+ * surface in response to the configure event, then the client
+ * must make an ack_configure request sometime before the commit
+ * request, passing along the serial of the configure event.
+ *
+ * For instance, for toplevel surfaces the compositor might use this
+ * information to move a surface to the top left only when the client has
+ * drawn itself for the maximized or fullscreen state.
+ *
+ * If the client receives multiple configure events before it
+ * can respond to one, it only has to ack the last configure event.
+ *
+ * A client is not required to commit immediately after sending
+ * an ack_configure request - it may even ack_configure several times
+ * before its next surface commit.
+ *
+ * A client may send multiple ack_configure requests before committing, but
+ * only the last request sent before a commit indicates which configure
+ * event the client really is responding to.
+ */
+static inline void
+zxdg_surface_v6_ack_configure(struct zxdg_surface_v6 *zxdg_surface_v6, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_surface_v6,
+			 ZXDG_SURFACE_V6_ACK_CONFIGURE, serial);
+}
+
+#ifndef ZXDG_TOPLEVEL_V6_RESIZE_EDGE_ENUM
+#define ZXDG_TOPLEVEL_V6_RESIZE_EDGE_ENUM
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ * edge values for resizing
+ *
+ * These values are used to indicate which edge of a surface
+ * is being dragged in a resize operation.
+ */
+enum zxdg_toplevel_v6_resize_edge {
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_NONE = 0,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP = 1,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM = 2,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_LEFT = 4,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_LEFT = 5,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_LEFT = 6,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_RIGHT = 8,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_TOP_RIGHT = 9,
+	ZXDG_TOPLEVEL_V6_RESIZE_EDGE_BOTTOM_RIGHT = 10,
+};
+#endif /* ZXDG_TOPLEVEL_V6_RESIZE_EDGE_ENUM */
+
+#ifndef ZXDG_TOPLEVEL_V6_STATE_ENUM
+#define ZXDG_TOPLEVEL_V6_STATE_ENUM
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ * the surface is now activated
+ *
+ * Client window decorations should be painted as if the window is
+ * active. Do not assume this means that the window actually has
+ * keyboard or pointer focus.
+ */
+enum zxdg_toplevel_v6_state {
+	/**
+	 * the surface is maximized
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_MAXIMIZED = 1,
+	/**
+	 * the surface is fullscreen
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_FULLSCREEN = 2,
+	/**
+	 * the surface is being resized
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_RESIZING = 3,
+	/**
+	 * the surface is now activated
+	 */
+	ZXDG_TOPLEVEL_V6_STATE_ACTIVATED = 4,
+};
+#endif /* ZXDG_TOPLEVEL_V6_STATE_ENUM */
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ * @struct zxdg_toplevel_v6_listener
+ */
+struct zxdg_toplevel_v6_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * This configure event asks the client to resize its toplevel
+	 * surface or to change its state. The configured state should not
+	 * be applied immediately. See xdg_surface.configure for details.
+	 *
+	 * The width and height arguments specify a hint to the window
+	 * about how its surface should be resized in window geometry
+	 * coordinates. See set_window_geometry.
+	 *
+	 * If the width or height arguments are zero, it means the client
+	 * should decide its own window dimension. This may happen when the
+	 * compositor needs to configure the state of the surface but
+	 * doesn't have any information about any previous or expected
+	 * dimension.
+	 *
+	 * The states listed in the event specify how the width/height
+	 * arguments should be interpreted, and possibly how it should be
+	 * drawn.
+	 *
+	 * Clients must send an ack_configure in response to this event.
+	 * See xdg_surface.configure and xdg_surface.ack_configure for
+	 * details.
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_toplevel_v6 *zxdg_toplevel_v6,
+			  int32_t width,
+			  int32_t height,
+			  struct wl_array *states);
+	/**
+	 * surface wants to be closed
+	 *
+	 * The close event is sent by the compositor when the user wants
+	 * the surface to be closed. This should be equivalent to the user
+	 * clicking the close button in client-side decorations, if your
+	 * application has any.
+	 *
+	 * This is only a request that the user intends to close the
+	 * window. The client may choose to ignore this request, or show a
+	 * dialog to ask the user to save their data, etc.
+	 */
+	void (*close)(void *data,
+		      struct zxdg_toplevel_v6 *zxdg_toplevel_v6);
+};
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+static inline int
+zxdg_toplevel_v6_add_listener(struct zxdg_toplevel_v6 *zxdg_toplevel_v6,
+			      const struct zxdg_toplevel_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_toplevel_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_TOPLEVEL_V6_DESTROY 0
+#define ZXDG_TOPLEVEL_V6_SET_PARENT 1
+#define ZXDG_TOPLEVEL_V6_SET_TITLE 2
+#define ZXDG_TOPLEVEL_V6_SET_APP_ID 3
+#define ZXDG_TOPLEVEL_V6_SHOW_WINDOW_MENU 4
+#define ZXDG_TOPLEVEL_V6_MOVE 5
+#define ZXDG_TOPLEVEL_V6_RESIZE 6
+#define ZXDG_TOPLEVEL_V6_SET_MAX_SIZE 7
+#define ZXDG_TOPLEVEL_V6_SET_MIN_SIZE 8
+#define ZXDG_TOPLEVEL_V6_SET_MAXIMIZED 9
+#define ZXDG_TOPLEVEL_V6_UNSET_MAXIMIZED 10
+#define ZXDG_TOPLEVEL_V6_SET_FULLSCREEN 11
+#define ZXDG_TOPLEVEL_V6_UNSET_FULLSCREEN 12
+#define ZXDG_TOPLEVEL_V6_SET_MINIMIZED 13
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_CLOSE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_PARENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_TITLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_APP_ID_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SHOW_WINDOW_MENU_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_MOVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_RESIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MAX_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MIN_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_UNSET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_UNSET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+#define ZXDG_TOPLEVEL_V6_SET_MINIMIZED_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_toplevel_v6 */
+static inline void
+zxdg_toplevel_v6_set_user_data(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_toplevel_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_toplevel_v6 */
+static inline void *
+zxdg_toplevel_v6_get_user_data(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_toplevel_v6);
+}
+
+static inline uint32_t
+zxdg_toplevel_v6_get_version(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Unmap and destroy the window. The window will be effectively
+ * hidden from the user's point of view, and all state like
+ * maximization, fullscreen, and so on, will be lost.
+ */
+static inline void
+zxdg_toplevel_v6_destroy(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_toplevel_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set the "parent" of this surface. This window should be stacked
+ * above a parent. The parent surface must be mapped as long as this
+ * surface is mapped.
+ *
+ * Parent windows should be set on dialogs, toolboxes, or other
+ * "auxiliary" surfaces, so that the parent is raised when the dialog
+ * is raised.
+ */
+static inline void
+zxdg_toplevel_v6_set_parent(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct zxdg_toplevel_v6 *parent)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_PARENT, parent);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set a short title for the surface.
+ *
+ * This string may be used to identify the surface in a task bar,
+ * window list, or other user interface elements provided by the
+ * compositor.
+ *
+ * The string must be encoded in UTF-8.
+ */
+static inline void
+zxdg_toplevel_v6_set_title(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, const char *title)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_TITLE, title);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set an application identifier for the surface.
+ *
+ * The app ID identifies the general class of applications to which
+ * the surface belongs. The compositor can use this to group multiple
+ * surfaces together, or to determine how to launch a new application.
+ *
+ * For D-Bus activatable applications, the app ID is used as the D-Bus
+ * service name.
+ *
+ * The compositor shell will try to group application surfaces together
+ * by their app ID. As a best practice, it is suggested to select app
+ * ID's that match the basename of the application's .desktop file.
+ * For example, "org.freedesktop.FooViewer" where the .desktop file is
+ * "org.freedesktop.FooViewer.desktop".
+ *
+ * See the desktop-entry specification [0] for more details on
+ * application identifiers and how they relate to well-known D-Bus
+ * names and .desktop files.
+ *
+ * [0] http://standards.freedesktop.org/desktop-entry-spec/
+ */
+static inline void
+zxdg_toplevel_v6_set_app_id(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, const char *app_id)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_APP_ID, app_id);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Clients implementing client-side decorations might want to show
+ * a context menu when right-clicking on the decorations, giving the
+ * user a menu that they can use to maximize or minimize the window.
+ *
+ * This request asks the compositor to pop up such a window menu at
+ * the given position, relative to the local surface coordinates of
+ * the parent surface. There are no guarantees as to what menu items
+ * the window menu contains.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event.
+ */
+static inline void
+zxdg_toplevel_v6_show_window_menu(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_seat *seat, uint32_t serial, int32_t x, int32_t y)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SHOW_WINDOW_MENU, seat, serial, x, y);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Start an interactive, user-driven move of the surface.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event. The passed
+ * serial is used to determine the type of interactive move (touch,
+ * pointer, etc).
+ *
+ * The server may ignore move requests depending on the state of
+ * the surface (e.g. fullscreen or maximized), or if the passed serial
+ * is no longer valid.
+ *
+ * If triggered, the surface will lose the focus of the device
+ * (wl_pointer, wl_touch, etc) used for the move. It is up to the
+ * compositor to visually indicate that the move is taking place, such as
+ * updating a pointer cursor, during the move. There is no guarantee
+ * that the device focus will return when the move is completed.
+ */
+static inline void
+zxdg_toplevel_v6_move(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_MOVE, seat, serial);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Start a user-driven, interactive resize of the surface.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event. The passed
+ * serial is used to determine the type of interactive resize (touch,
+ * pointer, etc).
+ *
+ * The server may ignore resize requests depending on the state of
+ * the surface (e.g. fullscreen or maximized).
+ *
+ * If triggered, the client will receive configure events with the
+ * "resize" state enum value and the expected sizes. See the "resize"
+ * enum value for more details about what is required. The client
+ * must also acknowledge configure events using "ack_configure". After
+ * the resize is completed, the client will receive another "configure"
+ * event without the resize state.
+ *
+ * If triggered, the surface also will lose the focus of the device
+ * (wl_pointer, wl_touch, etc) used for the resize. It is up to the
+ * compositor to visually indicate that the resize is taking place,
+ * such as updating a pointer cursor, during the resize. There is no
+ * guarantee that the device focus will return when the resize is
+ * completed.
+ *
+ * The edges parameter specifies how the surface should be resized,
+ * and is one of the values of the resize_edge enum. The compositor
+ * may use this information to update the surface position for
+ * example when dragging the top left corner. The compositor may also
+ * use this information to adapt its behavior, e.g. choose an
+ * appropriate cursor image.
+ */
+static inline void
+zxdg_toplevel_v6_resize(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_seat *seat, uint32_t serial, uint32_t edges)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_RESIZE, seat, serial, edges);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set a maximum size for the window.
+ *
+ * The client can specify a maximum size so that the compositor does
+ * not try to configure the window beyond this size.
+ *
+ * The width and height arguments are in window geometry coordinates.
+ * See xdg_surface.set_window_geometry.
+ *
+ * Values set in this way are double-buffered. They will get applied
+ * on the next commit.
+ *
+ * The compositor can use this information to allow or disallow
+ * different states like maximize or fullscreen and draw accurate
+ * animations.
+ *
+ * Similarly, a tiling window manager may use this information to
+ * place and resize client windows in a more effective way.
+ *
+ * The client should not rely on the compositor to obey the maximum
+ * size. The compositor may decide to ignore the values set by the
+ * client and request a larger size.
+ *
+ * If never set, or a value of zero in the request, means that the
+ * client has no expected maximum size in the given dimension.
+ * As a result, a client wishing to reset the maximum size
+ * to an unspecified state can use zero for width and height in the
+ * request.
+ *
+ * Requesting a maximum size to be smaller than the minimum size of
+ * a surface is illegal and will result in a protocol error.
+ *
+ * The width and height must be greater than or equal to zero. Using
+ * strictly negative values for width and height will result in a
+ * protocol error.
+ */
+static inline void
+zxdg_toplevel_v6_set_max_size(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MAX_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Set a minimum size for the window.
+ *
+ * The client can specify a minimum size so that the compositor does
+ * not try to configure the window below this size.
+ *
+ * The width and height arguments are in window geometry coordinates.
+ * See xdg_surface.set_window_geometry.
+ *
+ * Values set in this way are double-buffered. They will get applied
+ * on the next commit.
+ *
+ * The compositor can use this information to allow or disallow
+ * different states like maximize or fullscreen and draw accurate
+ * animations.
+ *
+ * Similarly, a tiling window manager may use this information to
+ * place and resize client windows in a more effective way.
+ *
+ * The client should not rely on the compositor to obey the minimum
+ * size. The compositor may decide to ignore the values set by the
+ * client and request a smaller size.
+ *
+ * If never set, or a value of zero in the request, means that the
+ * client has no expected minimum size in the given dimension.
+ * As a result, a client wishing to reset the minimum size
+ * to an unspecified state can use zero for width and height in the
+ * request.
+ *
+ * Requesting a minimum size to be larger than the maximum size of
+ * a surface is illegal and will result in a protocol error.
+ *
+ * The width and height must be greater than or equal to zero. Using
+ * strictly negative values for width and height will result in a
+ * protocol error.
+ */
+static inline void
+zxdg_toplevel_v6_set_min_size(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MIN_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Maximize the surface.
+ *
+ * After requesting that the surface should be maximized, the compositor
+ * will respond by emitting a configure event with the "maximized" state
+ * and the required window geometry. The client should then update its
+ * content, drawing it in a maximized state, i.e. without shadow or other
+ * decoration outside of the window geometry. The client must also
+ * acknowledge the configure when committing the new content (see
+ * ack_configure).
+ *
+ * It is up to the compositor to decide how and where to maximize the
+ * surface, for example which output and what region of the screen should
+ * be used.
+ *
+ * If the surface was already maximized, the compositor will still emit
+ * a configure event with the "maximized" state.
+ */
+static inline void
+zxdg_toplevel_v6_set_maximized(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MAXIMIZED);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Unmaximize the surface.
+ *
+ * After requesting that the surface should be unmaximized, the compositor
+ * will respond by emitting a configure event without the "maximized"
+ * state. If available, the compositor will include the window geometry
+ * dimensions the window had prior to being maximized in the configure
+ * request. The client must then update its content, drawing it in a
+ * regular state, i.e. potentially with shadow, etc. The client must also
+ * acknowledge the configure when committing the new content (see
+ * ack_configure).
+ *
+ * It is up to the compositor to position the surface after it was
+ * unmaximized; usually the position the surface had before maximizing, if
+ * applicable.
+ *
+ * If the surface was already not maximized, the compositor will still
+ * emit a configure event without the "maximized" state.
+ */
+static inline void
+zxdg_toplevel_v6_unset_maximized(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_UNSET_MAXIMIZED);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Make the surface fullscreen.
+ *
+ * You can specify an output that you would prefer to be fullscreen.
+ * If this value is NULL, it's up to the compositor to choose which
+ * display will be used to map this surface.
+ *
+ * If the surface doesn't cover the whole output, the compositor will
+ * position the surface in the center of the output and compensate with
+ * black borders filling the rest of the output.
+ */
+static inline void
+zxdg_toplevel_v6_set_fullscreen(struct zxdg_toplevel_v6 *zxdg_toplevel_v6, struct wl_output *output)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_FULLSCREEN, output);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ */
+static inline void
+zxdg_toplevel_v6_unset_fullscreen(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_UNSET_FULLSCREEN);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_v6
+ *
+ * Request that the compositor minimize your surface. There is no
+ * way to know if the surface is currently minimized, nor is there
+ * any way to unset minimization on this surface.
+ *
+ * If you are looking to throttle redrawing when minimized, please
+ * instead use the wl_surface.frame event for this, as this will
+ * also work with live previews on windows in Alt-Tab, Expose or
+ * similar compositor features.
+ */
+static inline void
+zxdg_toplevel_v6_set_minimized(struct zxdg_toplevel_v6 *zxdg_toplevel_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_v6,
+			 ZXDG_TOPLEVEL_V6_SET_MINIMIZED);
+}
+
+#ifndef ZXDG_POPUP_V6_ERROR_ENUM
+#define ZXDG_POPUP_V6_ERROR_ENUM
+enum zxdg_popup_v6_error {
+	/**
+	 * tried to grab after being mapped
+	 */
+	ZXDG_POPUP_V6_ERROR_INVALID_GRAB = 0,
+};
+#endif /* ZXDG_POPUP_V6_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ * @struct zxdg_popup_v6_listener
+ */
+struct zxdg_popup_v6_listener {
+	/**
+	 * configure the popup surface
+	 *
+	 * This event asks the popup surface to configure itself given
+	 * the configuration. The configured state should not be applied
+	 * immediately. See xdg_surface.configure for details.
+	 *
+	 * The x and y arguments represent the position the popup was
+	 * placed at given the xdg_positioner rule, relative to the upper
+	 * left corner of the window geometry of the parent surface.
+	 * @param x x position relative to parent surface window geometry
+	 * @param y y position relative to parent surface window geometry
+	 * @param width window geometry width
+	 * @param height window geometry height
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_popup_v6 *zxdg_popup_v6,
+			  int32_t x,
+			  int32_t y,
+			  int32_t width,
+			  int32_t height);
+	/**
+	 * popup interaction is done
+	 *
+	 * The popup_done event is sent out when a popup is dismissed by
+	 * the compositor. The client should destroy the xdg_popup object
+	 * at this point.
+	 */
+	void (*popup_done)(void *data,
+			   struct zxdg_popup_v6 *zxdg_popup_v6);
+};
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+static inline int
+zxdg_popup_v6_add_listener(struct zxdg_popup_v6 *zxdg_popup_v6,
+			   const struct zxdg_popup_v6_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_popup_v6,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_POPUP_V6_DESTROY 0
+#define ZXDG_POPUP_V6_GRAB 1
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_POPUP_DONE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_popup_v6
+ */
+#define ZXDG_POPUP_V6_GRAB_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_popup_v6 */
+static inline void
+zxdg_popup_v6_set_user_data(struct zxdg_popup_v6 *zxdg_popup_v6, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_popup_v6, user_data);
+}
+
+/** @ingroup iface_zxdg_popup_v6 */
+static inline void *
+zxdg_popup_v6_get_user_data(struct zxdg_popup_v6 *zxdg_popup_v6)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_popup_v6);
+}
+
+static inline uint32_t
+zxdg_popup_v6_get_version(struct zxdg_popup_v6 *zxdg_popup_v6)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_popup_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ *
+ * This destroys the popup. Explicitly destroying the xdg_popup
+ * object will also dismiss the popup, and unmap the surface.
+ *
+ * If this xdg_popup is not the "topmost" popup, a protocol error
+ * will be sent.
+ */
+static inline void
+zxdg_popup_v6_destroy(struct zxdg_popup_v6 *zxdg_popup_v6)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_popup_v6,
+			 ZXDG_POPUP_V6_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_popup_v6);
+}
+
+/**
+ * @ingroup iface_zxdg_popup_v6
+ *
+ * This request makes the created popup take an explicit grab. An explicit
+ * grab will be dismissed when the user dismisses the popup, or when the
+ * client destroys the xdg_popup. This can be done by the user clicking
+ * outside the surface, using the keyboard, or even locking the screen
+ * through closing the lid or a timeout.
+ *
+ * If the compositor denies the grab, the popup will be immediately
+ * dismissed.
+ *
+ * This request must be used in response to some sort of user action like a
+ * button press, key press, or touch down event. The serial number of the
+ * event should be passed as 'serial'.
+ *
+ * The parent of a grabbing popup must either be an xdg_toplevel surface or
+ * another xdg_popup with an explicit grab. If the parent is another
+ * xdg_popup it means that the popups are nested, with this popup now being
+ * the topmost popup.
+ *
+ * Nested popups must be destroyed in the reverse order they were created
+ * in, e.g. the only popup you are allowed to destroy at all times is the
+ * topmost one.
+ *
+ * When compositors choose to dismiss a popup, they may dismiss every
+ * nested grabbing popup as well. When a compositor dismisses popups, it
+ * will follow the same dismissing order as required from the client.
+ *
+ * The parent of a grabbing popup must either be another xdg_popup with an
+ * active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
+ * explicit grabs already taken.
+ *
+ * If the topmost grabbing popup is destroyed, the grab will be returned to
+ * the parent of the popup, if that parent previously had an explicit grab.
+ *
+ * If the parent is a grabbing popup which has already been dismissed, this
+ * popup will be immediately dismissed. If the parent is a popup that did
+ * not take an explicit grab, an error will be raised.
+ *
+ * During a popup grab, the client owning the grab will receive pointer
+ * and touch events for all their surfaces as normal (similar to an
+ * "owner-events" grab in X11 parlance), while the top most grabbing popup
+ * will always have keyboard focus.
+ */
+static inline void
+zxdg_popup_v6_grab(struct zxdg_popup_v6 *zxdg_popup_v6, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_popup_v6,
+			 ZXDG_POPUP_V6_GRAB, seat, serial);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/cmake/modules/FindWestonClient.cmake b/cmake/modules/FindWestonClient.cmake
new file mode 100644
index 0000000..22b68c3
--- /dev/null
+++ b/cmake/modules/FindWestonClient.cmake
@@ -0,0 +1,59 @@
+# - Try to find Weston library.
+# Once done this will define
+#  WESTON_FOUND - System has weston
+#  WESTON_INCLUDE_DIRS - The weston include directories
+#  WESTON_LIBRARIES    - The libraries needed to use weston
+#
+#  WESTON::WESTON, the weston compositor
+#
+# Copyright (C) 2015 Metrological.
+# Copyright (C) 2019 Linaro.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1.  Redistributions of source code must retain the above copyright
+#     notice, this list of conditions and the following disclaimer.
+# 2.  Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND ITS CONTRIBUTORS ``AS
+# IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR ITS
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+find_package(PkgConfig)
+pkg_check_modules(PC_WESTON weston-compositor)
+
+find_library(WESTON_CLIENT_LIB NAMES weston-desktop-5
+        HINTS ${PC_WESTON_LIBDIR} ${PC_WESTON_LIBRARY_DIRS}
+)
+
+set (WESTON_CLIENT_LIBRARIES ${PC_WESTON_LIBRARIES})
+
+set (WESTON_CLIENT_FOUND TRUE)
+
+if(WESTON_CLIENT_FOUND AND NOT TARGET WestonClient::WestonClient)
+    set(WESTON_CLIENT_LIB_CLIENT_LINK_LIBRARIES "${WESTON_CLIENT_LIB}")
+    add_library(WestonClient::WestonClient UNKNOWN IMPORTED)
+    set_target_properties(WestonClient::WestonClient PROPERTIES
+            IMPORTED_LINK_INTERFACE_LANGUAGES "C"
+            IMPORTED_LOCATION "${WESTON_CLIENT_LIB}"
+            INTERFACE_INCLUDE_DIRECTORIES ""
+            INTERFACE_COMPILE_OPTIONS "${WESTON_CLIENT_CFLAGS_OTHER}"
+            INTERFACE_LINK_LIBRARIES "${WESTON_CLIENT_LIB_CLIENT_LINK_LIBRARIES}"
+            )
+endif()
+
+include(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(PC_WESTON DEFAULT_MSG WESTON_CLIENT_FOUND)
+
+mark_as_advanced(WESTON_CLIENT_LIBRARIES)
-- 
2.7.4

