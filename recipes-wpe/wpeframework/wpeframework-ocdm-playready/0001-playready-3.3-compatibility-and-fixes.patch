From 714eecc1c8de46252bf3d9f498bafc5f64c1160a Mon Sep 17 00:00:00 2001
From: Moorthy Baskar <moorthy.baskaravenkatraman-sambamoorthy@linaro.org>
Date: Wed, 18 Sep 2019 15:08:48 +0200
Subject: [PATCH] playready 3.3 compatibility and fixes

  - null set to clear content ptr. after Decrypt_Opaque() is removed, added before the call
  - redefinition of PR_3_3 removed
  - DecryptContext pointer in DRM APIs are mentioned based on version
  - introduced NETFLIX variable to conditionally called Netflix DRM APIs
  - CMakelists.txt - NETFLIX option enabled (can be disabled from a bbappend)
  - CMakelists.txt - linked playready static libraries through variable

Signed-off-by: Moorthy Baskar <moorthy.baskaravenkatraman-sambamoorthy@linaro.org>
---
 CMakeLists.txt      | 12 ++++++++-
 MediaSession.cpp    | 72 ++++++++++++++++++++++++++++++++++-------------------
 MediaSession.h      |  4 ++-
 MediaSessionExt.cpp | 38 ++++++++++++++++++++++++++++
 MediaSystem.cpp     | 56 +++++++++++++++++++++++++++++++++++++----
 5 files changed, 149 insertions(+), 33 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 3085f41..a2a1aa1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -7,6 +7,8 @@ list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
 set(MODULE_NAME Playready)
 
+option(NETFLIX "Enable Netflix DRM" ON)
+
 find_package(PlayReady REQUIRED)
 
 add_library(${MODULE_NAME} SHARED
@@ -18,18 +20,26 @@ set_target_properties(${MODULE_NAME} PROPERTIES
         CXX_STANDARD 11
         CXX_STANDARD_REQUIRED YES)
 
+if (NETFLIX)
 include("${PLAYREADY_INCLUDE}/playready.cmake")
 
+add_compile_definitions(NETFLIX)
+endif()
+
 target_include_directories(${MODULE_NAME}
     PRIVATE
     "${CMAKE_SYSROOT}/usr/include"
     "${CMAKE_SYSROOT}/usr/include/${NAMESPACE}"
     ${PLAYREADY_INCLUDE_DIRS})
 
-
+if (NETFLIX)
 target_link_libraries(${MODULE_NAME}
     PRIVATE
         PlayReady::PlayReady)
+else()
+target_link_libraries(${MODULE_NAME}
+    ${PLAYREADY_LIBRARIES})
+endif()
 
 # Library installation section
 set_target_properties(${MODULE_NAME} PROPERTIES SUFFIX ".drm")
diff --git a/MediaSession.cpp b/MediaSession.cpp
index bcac26b..915ea0a 100644
--- a/MediaSession.cpp
+++ b/MediaSession.cpp
@@ -73,10 +73,14 @@ const DRM_WCHAR g_rgwchCDMDrmStoreName[] = {WCHAR_CAST('/'), WCHAR_CAST('t'), WC
 const DRM_CONST_STRING g_dstrCDMDrmStoreName = CREATE_DRM_STRING(g_rgwchCDMDrmStoreName);
 
 #ifdef PR_3_3
+#ifdef NETFLIX
 const DRM_CONST_STRING *g_rgpdstrRights[1] = {&g_dstrDRM_RIGHT_PLAYBACK};
 #else
 const DRM_CONST_STRING *g_rgpdstrRights[1] = {&g_dstrWMDRM_RIGHT_PLAYBACK};
 #endif
+#else
+const DRM_CONST_STRING *g_rgpdstrRights[1] = {&g_dstrWMDRM_RIGHT_PLAYBACK};
+#endif
 
 // Parse out the first PlayReady initialization header found in the concatenated
 // block of headers in _initData_.
@@ -361,7 +365,11 @@ bool MediaKeySession::playreadyGenerateKeyRequest() {
                         DRM_NO_OF(g_rgpdstrRights),
                         _PolicyCallback,
                         nullptr,
+#ifdef NETFLIX
                         &m_oDecryptContext);
+#else
+                        m_oDecryptContext);
+#endif
 #endif
 
   // FIXME :  Check add case Play rights already acquired
@@ -544,11 +552,13 @@ CDMi_RESULT MediaKeySession::Decrypt(
         return CDMi_S_FALSE;
     }
     
-    DRM_RESULT err = DRM_SUCCESS;
+    DRM_RESULT dr = DRM_SUCCESS;
+    DRM_AES_COUNTER_MODE_CONTEXT ctrContext = { 0 };
+    DRM_DWORD rgdwMappings[2];
+
     if (!initWithLast15) {
 /* PRv3.3 support */
 #ifdef PR_3_3
-      DRM_DWORD rgdwMappings[2];
       if( f_pcbOpaqueClearContent == NULL || f_ppbOpaqueClearContent == NULL )
       {
           dr = DRM_E_INVALIDARG;
@@ -561,27 +571,29 @@ CDMi_RESULT MediaKeySession::Decrypt(
       ChkBOOL(m_eKeyState == KEY_READY, DRM_E_INVALIDARG);
       ChkArg(f_pbIV != NULL && f_cbIV == sizeof(DRM_UINT64));
 #else
-      err = Drm_Reader_InitDecrypt(m_oDecryptContext, nullptr, 0);
+      dr = Drm_Reader_InitDecrypt(m_oDecryptContext, nullptr, 0);
 #endif
-    } else {
+    }
+#ifdef NETFLIX
+    else {
         // Initialize the decryption context for Cocktail packaged
         // content. This is a no-op for AES packaged content.
         if (payloadDataSize <= 15)
         {
-            err = Drm_Reader_InitDecrypt(m_oDecryptContext, (DRM_BYTE*)payloadData, payloadDataSize);
+            dr = Drm_Reader_InitDecrypt(m_oDecryptContext, (DRM_BYTE*)payloadData, payloadDataSize);
         }
         else
         {
-            err = Drm_Reader_InitDecrypt(m_oDecryptContext, (DRM_BYTE*)(payloadData + payloadDataSize - 15), payloadDataSize);
+            dr = Drm_Reader_InitDecrypt(m_oDecryptContext, (DRM_BYTE*)(payloadData + payloadDataSize - 15), payloadDataSize);
         }
     }
-    if (DRM_FAILED(err))
+#endif
+    if (DRM_FAILED(dr))
     {
         fprintf(stderr, "Failed to init decrypt\n");
         return CDMi_S_FALSE;
     }
 
-    DRM_AES_COUNTER_MODE_CONTEXT ctrContext = { 0 };
     // TODO: can be done in another way (now abusing "initWithLast15" variable)
     if (initWithLast15) {
         // Netflix case
@@ -600,8 +612,9 @@ CDMi_RESULT MediaKeySession::Decrypt(
        MEMCPY(&ctrContext.qwInitializationVector, f_pbIV, f_cbIV);
     }
 
+/* PRv3.3 support */
 #ifdef PR_3_3
-    if ( NULL == f_pdwSubSampleMapping )
+   if ( NULL == f_pdwSubSampleMapping )
     {
         rgdwMappings[0] = 0;
         rgdwMappings[1] = payloadDataSize;
@@ -609,18 +622,31 @@ CDMi_RESULT MediaKeySession::Decrypt(
         f_cdwSubSampleMapping = NO_OF(rgdwMappings);
     }
 
+    if( f_pcbOpaqueClearContent != NULL )
+    {
+        *f_pcbOpaqueClearContent = 0;
+    }
+    if( f_ppbOpaqueClearContent != NULL )
+    {
+        *f_ppbOpaqueClearContent = NULL;
+    }
+
     ChkDR(Drm_Reader_DecryptOpaque(
+#ifdef NETFLIX
         &m_oDecryptContext,
+#else
+        m_oDecryptContext,
+#endif
         f_cdwSubSampleMapping,
         reinterpret_cast<const DRM_DWORD*>(f_pdwSubSampleMapping),
-        oAESContext.qwInitializationVector,
+        ctrContext.qwInitializationVector,
         payloadDataSize,
         (DRM_BYTE *) payloadData,
         reinterpret_cast<DRM_DWORD*>(f_pcbOpaqueClearContent),
         reinterpret_cast<DRM_BYTE**>(f_ppbOpaqueClearContent)));
 #else
-    err = Drm_Reader_Decrypt(m_oDecryptContext, &ctrContext, (DRM_BYTE*)payloadData, payloadDataSize);
-    if (DRM_FAILED(err))
+    dr = Drm_Reader_Decrypt(m_oDecryptContext, &ctrContext, (DRM_BYTE*)payloadData, payloadDataSize);
+    if (DRM_FAILED(dr))
     {
         fprintf(stderr, "Failed to run Drm_Reader_Decrypt\n");
         return CDMi_S_FALSE;
@@ -629,8 +655,7 @@ CDMi_RESULT MediaKeySession::Decrypt(
 
     // Call commit during the decryption of the first sample.
     if (!m_fCommit) {
-        //err = Drm_Reader_Commit(m_poAppContext, &opencdm_output_levels_callback, &levels_);
-        err = Drm_Reader_Commit(m_poAppContext, _PolicyCallback, nullptr); // TODO: pass along user data
+        ChkDR(Drm_Reader_Commit(m_poAppContext, _PolicyCallback, nullptr)); // TODO: pass along user data
         m_fCommit = TRUE;
     }
 
@@ -640,17 +665,13 @@ CDMi_RESULT MediaKeySession::Decrypt(
     *f_ppbOpaqueClearContent = (uint8_t *)payloadData;
 #endif
 
-/* PRv3.3 support */
-#ifdef PR_3_3
-        if( f_pcbOpaqueClearContent != NULL )
-          {
-              *f_pcbOpaqueClearContent = 0;
-          }
-          if( f_ppbOpaqueClearContent != NULL )
-          {
-              *f_ppbOpaqueClearContent = NULL;
-          }
-#endif
+ErrorExit:
+    if (DRM_FAILED(dr)) {
+      const DRM_CHAR* description;
+      DRM_ERR_GetErrorNameFromCode(dr, &description);
+      printf("playready error on Decrypt: %s\n", description);
+      return CDMi_S_FALSE;
+    }
 
     return CDMi_SUCCESS;
 }
@@ -662,7 +683,6 @@ CDMi_RESULT MediaKeySession::ReleaseClearContent(
     uint8_t  *f_pbClearContentOpaque ) {
 
   return CDMi_SUCCESS;
-
 }
 
 }  // namespace CDMi
diff --git a/MediaSession.h b/MediaSession.h
index 32df16a..7a74d74 100644
--- a/MediaSession.h
+++ b/MediaSession.h
@@ -22,7 +22,6 @@
 #include <drmmathsafe.h>
 #include <drmtypes.h>
 #ifndef SIZEOF
-#define PR_3_3
 #define SIZEOF sizeof
 #include <drmcrt.h>
 #undef min
@@ -33,6 +32,9 @@
 #endif
 #include <drmerr.h>
 #include <drmerror.h>
+#if defined(PR_3_3) && !defined(NETFLIX)
+#include <drmversionconstants.h>
+#endif
 
 #undef __in
 #undef __out
diff --git a/MediaSessionExt.cpp b/MediaSessionExt.cpp
index ea43079..c12e67a 100644
--- a/MediaSessionExt.cpp
+++ b/MediaSessionExt.cpp
@@ -12,6 +12,7 @@ using namespace WPEFramework;
 using SafeCriticalSection = Core::SafeSyncType<Core::CriticalSection>;
 extern Core::CriticalSection drmAppContextMutex_;
 
+#ifdef NETFLIX
 // The rights we want to request.
 const DRM_WCHAR PLAY[] = { ONE_WCHAR('P', '\0'),
                            ONE_WCHAR('l', '\0'),
@@ -19,7 +20,20 @@ const DRM_WCHAR PLAY[] = { ONE_WCHAR('P', '\0'),
                            ONE_WCHAR('y', '\0'),
                            ONE_WCHAR('\0', '\0')
 };
+#else
+const DRM_WCHAR PLAY[] = { DRM_ONE_WCHAR('P', '\0'),
+                           DRM_ONE_WCHAR('l', '\0'),
+                           DRM_ONE_WCHAR('a', '\0'),
+                           DRM_ONE_WCHAR('y', '\0'),
+                           DRM_ONE_WCHAR('\0', '\0')
+};
+#endif
+
+#ifdef NETFLIX
 const DRM_CONST_STRING PLAY_RIGHT = CREATE_DRM_STRING(PLAY);
+#else
+const DRM_CONST_STRING PLAY_RIGHT = DRM_CREATE_DRM_STRING(PLAY);
+#endif
 static const DRM_CONST_STRING* RIGHTS[] = { &PLAY_RIGHT };
 
 namespace CDMi {
@@ -103,9 +117,11 @@ CDMi_RESULT MediaKeySession::StoreLicenseData(const uint8_t licenseData[], uint3
     SafeCriticalSection systemLock(drmAppContextMutex_);
 
     // Make sure PlayReady still expects a 16 byte array.
+#ifdef NETFLIX
     ASSERT(TEE_SESSION_ID_LEN == 16);
 
     memset(secureStopId, 0, TEE_SESSION_ID_LEN);
+#endif
 
     DRM_RESULT err;
 
@@ -134,6 +150,7 @@ CDMi_RESULT MediaKeySession::StoreLicenseData(const uint8_t licenseData[], uint3
     localLicenseData.resize(licenseDataSize);
     memcpy(&localLicenseData[0], licenseData, licenseDataSize);
 
+#ifdef NETFLIX
     err = Drm_LicenseAcq_ProcessResponse_Netflix(m_poAppContext,
                                                  DRM_PROCESS_LIC_RESPONSE_NO_FLAGS,
                                                  nullptr, nullptr,
@@ -141,6 +158,7 @@ CDMi_RESULT MediaKeySession::StoreLicenseData(const uint8_t licenseData[], uint3
                                                  (DRM_DWORD)localLicenseData.size(),
                                                  secureStopId,
                                                  mLicenseResponse->get());
+#endif
     if (DRM_FAILED(err)) {
         fprintf(stderr, "Error: Drm_LicenseAcq_ProcessResponse_Netflix returned 0x%lX\n", (long)err);
         return CDMi_S_FALSE;
@@ -148,8 +166,10 @@ CDMi_RESULT MediaKeySession::StoreLicenseData(const uint8_t licenseData[], uint3
 
     // Also store copy of secure stop id in session struct
     mSecureStopId.clear();
+#ifdef NETFLIX
     mSecureStopId.resize(TEE_SESSION_ID_LEN);
     mSecureStopId.assign(secureStopId, secureStopId + TEE_SESSION_ID_LEN);
+#endif
 
     // All done.
     return CDMi_SUCCESS;
@@ -192,7 +212,9 @@ CDMi_RESULT MediaKeySession::GetChallengeDataExt(uint8_t * challenge, uint32_t &
         return CDMi_S_FALSE;
     }
 
+#ifdef NETFLIX
     mNounce.resize(TEE_SESSION_ID_LEN);
+#endif
 
     fprintf(stderr, "challengeSize: %u\n", challengeSize);
     fprintf(stderr, "challenge: %p\n", challenge);
@@ -204,7 +226,11 @@ CDMi_RESULT MediaKeySession::GetChallengeDataExt(uint8_t * challenge, uint32_t &
         passedChallenge = nullptr;
     }
 
+#ifdef NETFLIX
     err = Drm_LicenseAcq_GenerateChallenge_Netflix(m_poAppContext,
+#else
+    err = Drm_LicenseAcq_GenerateChallenge(m_poAppContext,
+#endif
                                                    RIGHTS,
                                                    sizeof(RIGHTS) / sizeof(DRM_CONST_STRING*),
                                                    nullptr,
@@ -212,7 +238,11 @@ CDMi_RESULT MediaKeySession::GetChallengeDataExt(uint8_t * challenge, uint32_t &
                                                    nullptr, nullptr,
                                                    nullptr, nullptr,
                                                    passedChallenge, &challengeSize,
+#ifdef NETFLIX
                                                    &mNounce[0], isLDL);
+#else
+                                                   nullptr);
+#endif
 
     fprintf(stderr, "ChallengeSize: %u\n", challengeSize);
 
@@ -233,11 +263,13 @@ CDMi_RESULT MediaKeySession::GetChallengeDataExt(uint8_t * challenge, uint32_t &
 CDMi_RESULT MediaKeySession::CancelChallengeDataExt()
 {
     SafeCriticalSection systemLock(drmAppContextMutex_);
+#ifdef NETFLIX
     DRM_RESULT err = Drm_LicenseAcq_CancelChallenge_Netflix(m_poAppContext, &mNounce[0]);
     if (DRM_FAILED(err)) {
         fprintf(stderr, "Error Drm_LicenseAcq_CancelChallenge_Netflix: 0x%08lx\n", static_cast<unsigned long>(err));
         return CDMi_S_FALSE;
     }
+#endif
     return CDMi_SUCCESS;
 }
 
@@ -270,6 +302,7 @@ CDMi_RESULT MediaKeySession::SelectKeyId(const uint8_t /* keyLength */, const ui
     m_oDecryptContext = new DRM_DECRYPT_CONTEXT;
     //Create a decrypt context and bind it with the drm context.
     memset(m_oDecryptContext, 0, sizeof(DRM_DECRYPT_CONTEXT));
+#ifdef NETFLIX
     if(mSecureStopId.size() == TEE_SESSION_ID_LEN ){
         err = Drm_Reader_Bind_Netflix(m_poAppContext,
                                       RIGHTS,
@@ -299,6 +332,7 @@ CDMi_RESULT MediaKeySession::SelectKeyId(const uint8_t /* keyLength */, const ui
         fprintf(stderr, "Error: secure stop ID is not valid\n");
         result = CDMi_S_FALSE;
     }
+#endif
     return result;
 }
 
@@ -313,7 +347,9 @@ CDMi_RESULT MediaKeySession::CleanDecryptContext()
     // Seems like we no longer have to worry about invalid app context, make sure with this ASSERT.
     ASSERT(m_poAppContext != nullptr);
     if (m_oDecryptContext) {
+#ifdef NETFLIX
         err = Drm_Reader_Unbind(m_poAppContext, m_oDecryptContext);
+#endif
         if (DRM_FAILED(err))
         {
             fprintf(stderr, "Error Drm_Reader_Unbind: 0x%08lx when creating temporary DRM_DECRYPT_CONTEXT\n",
@@ -355,6 +391,7 @@ CDMi_RESULT MediaKeySession::CleanDecryptContext()
         m_oDecryptContext = new DRM_DECRYPT_CONTEXT;
         memset(m_oDecryptContext, 0, sizeof(DRM_DECRYPT_CONTEXT));
 
+#ifdef NETFLIX
         if (mSecureStopId.size() == TEE_SESSION_ID_LEN )
         {
             err = Drm_Reader_Bind_Netflix(m_poAppContext,
@@ -381,6 +418,7 @@ CDMi_RESULT MediaKeySession::CleanDecryptContext()
             fprintf(stderr, "Error: secure stop ID is not valid\n");
             result = CDMi_S_FALSE;
         }
+#endif
     }
     if (m_poAppContext)
     {
diff --git a/MediaSystem.cpp b/MediaSystem.cpp
index a4ccfb0..a46508d 100644
--- a/MediaSystem.cpp
+++ b/MediaSystem.cpp
@@ -40,8 +40,13 @@ Core::CriticalSection drmAppContextMutex_;
 static DRM_WCHAR* createDrmWchar(std::string const& s) {
     DRM_WCHAR* w = new DRM_WCHAR[s.length() + 1];
     for (size_t i = 0; i < s.length(); ++i)
+#ifdef PR_3_3
+        w[i] = DRM_ONE_WCHAR(s[i], '\0');
+    w[s.length()] = DRM_ONE_WCHAR('\0', '\0');
+#else
         w[i] = ONE_WCHAR(s[i], '\0');
     w[s.length()] = ONE_WCHAR('\0', '\0');
+#endif
     return w;
 }
 
@@ -123,6 +128,7 @@ public:
        SafeCriticalSection lock(drmAppContextMutex_);
 
        DRM_UINT64 utctime64;
+#ifdef NETFLIX
        DRM_RESULT err = Drm_Clock_GetSystemTime(m_poAppContext.get(), &utctime64);
        if (err != DRM_SUCCESS) {
            fprintf(stderr, "Error: Drm_Clock_GetSystemTime returned 0x%lX\n", (long)err);
@@ -131,6 +137,7 @@ public:
        } else {
            return static_cast<uint64_t>(utctime64);
        }
+#endif
 
        return 0;
 
@@ -165,11 +172,13 @@ public:
         ASSERT(m_poAppContext.get() != nullptr);
 
         uint32_t ldlLimit = 0;
+#ifdef NETFLIX
         DRM_RESULT err = Drm_LicenseAcq_GetLdlSessionsLimit_Netflix(m_poAppContext.get(), &ldlLimit);
         if (err != DRM_SUCCESS) {
             fprintf(stderr, "Error: Drm_LicenseAcq_GetLdlSessionsLimit_Netflix returned 0x%lX\n", (long)err);
             return 0;
         }
+#endif
 
         return ldlLimit;
     }
@@ -177,13 +186,19 @@ public:
     bool IsSecureStopEnabled() override
     {
         SafeCriticalSection lock(drmAppContextMutex_);
+#ifdef NETFLIX
         return static_cast<bool>(Drm_SupportSecureStop());
+#else
+        return false;
+#endif
     }
 
     CDMi_RESULT EnableSecureStop(bool enable) override
     {
         SafeCriticalSection lock(drmAppContextMutex_);
+#ifdef NETFLIX
         Drm_TurnSecureStop(static_cast<int>(enable));
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -192,15 +207,20 @@ public:
     {
         SafeCriticalSection lock(drmAppContextMutex_);
         // if secure stop is not supported, return
-        DRM_BOOL supported = Drm_SupportSecureStop();
+        DRM_BOOL supported = FALSE;
+#ifdef NETFLIX
+        supported  = Drm_SupportSecureStop();
+#endif
         if (supported == FALSE)
             return 0;
 
         DRM_WORD numDeleted = 0;
+#ifdef NETFLIX
         DRM_RESULT err = Drm_ResetSecureStops(m_poAppContext.get(), &numDeleted);
         if (err != DRM_SUCCESS) {
             fprintf(stderr, "Drm_ResetSecureStops returned 0x%lx\n", (long)err);
         }
+#endif
         return numDeleted;
     }
 
@@ -209,10 +229,14 @@ public:
         SafeCriticalSection lock(drmAppContextMutex_);
 
         // if secure stop is not supported, return NotAllowed
-        DRM_BOOL supported = Drm_SupportSecureStop();
+        DRM_BOOL supported = FALSE;
+#ifdef NETFLIX
+        supported = Drm_SupportSecureStop();
+#endif
         if (supported == FALSE)
             return CDMi_SUCCESS;
 
+#ifdef NETFLIX
         DRM_BYTE sessionIds[TEE_MAX_NUM_SECURE_STOPS][TEE_SESSION_ID_LEN];
         DRM_RESULT err = Drm_GetSecureStopIds(m_poAppContext.get(), sessionIds, &count);
         if (err != DRM_SUCCESS) {
@@ -223,6 +247,7 @@ public:
         for (int i = 0; i < count; ++i) {
             memcpy(&ids[i * TEE_SESSION_ID_LEN], sessionIds[i], TEE_SESSION_ID_LEN);
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -236,7 +261,10 @@ public:
         SafeCriticalSection lock(drmAppContextMutex_);
 
         // if secure stop is not supported, return
-        DRM_BOOL supported = Drm_SupportSecureStop();
+        DRM_BOOL supported = FALSE;
+#ifdef NETFLIX
+        supported = Drm_SupportSecureStop();
+#endif
         if (supported == FALSE)
             return CDMi_SUCCESS;
 
@@ -245,6 +273,7 @@ public:
             return CDMi_S_FALSE;
         }
 
+#ifdef NETFLIX
         // convert our vector to the uuid, sessionID is only supposed to be 16 bytes long
         uint8_t uuid[TEE_SESSION_ID_LEN];
         memcpy(&uuid[0], &sessionID[0], TEE_SESSION_ID_LEN);
@@ -256,6 +285,7 @@ public:
             fprintf(stderr, "Drm_GetSecureStop(0) returned 0x%lx\n", (long)err);
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -269,7 +299,10 @@ public:
         SafeCriticalSection lock(drmAppContextMutex_);
 
         // if secure stop is not supported, return
-        DRM_BOOL supported = Drm_SupportSecureStop();
+        DRM_BOOL supported = FALSE;
+#ifdef NETFLIX
+        supported = Drm_SupportSecureStop();
+#endif
         if (supported == FALSE)
             return CDMi_SUCCESS;
 
@@ -278,7 +311,7 @@ public:
             return CDMi_INVALID_ARG;
         }
 
-
+#ifdef NETFLIX
         // convert our vector to the uuid, sessionID is only supposed to be 16 bytes long
         uint8_t uuid[TEE_SESSION_ID_LEN];
         memcpy(&uuid[0], &sessionID[0], TEE_SESSION_ID_LEN);
@@ -289,6 +322,7 @@ public:
         {
             fprintf(stderr, "Drm_CommitSecureStop returned 0x%lx\n", (long)err);
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -297,12 +331,14 @@ public:
     {
         SafeCriticalSection lock(drmAppContextMutex_);
 
+#ifdef NETFLIX
         DRM_RESULT err = Drm_DeleteKeyStore();
         if (err != DRM_SUCCESS)
         {
             fprintf(stderr, "Error: Drm_DeleteKeyStore returned 0x%lX\n", (long)err);
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -311,12 +347,14 @@ public:
     {
         SafeCriticalSection lock(drmAppContextMutex_);
 
+#ifdef NETFLIX
         DRM_RESULT err = Drm_DeleteSecureStore(&drmStore_);
         if (err != DRM_SUCCESS)
         {
             fprintf(stderr, "Error: Drm_DeleteSecureStore returned 0x%lX\n", (long)err);
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -333,12 +371,14 @@ public:
             return CDMi_S_FALSE;
         }
 
+#ifdef NETFLIX
         DRM_RESULT err = Drm_GetKeyStoreHash(keyStoreHash);
         if (err != DRM_SUCCESS)
         {
             fprintf(stderr, "Error: Drm_GetSecureStoreHash returned 0x%lX\n", (long)err);
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -355,12 +395,14 @@ public:
             return CDMi_S_FALSE;
         }
 
+#ifdef NETFLIX
         DRM_RESULT err = Drm_GetSecureStoreHash(&drmStore_, secureStoreHash);
         if (err != DRM_SUCCESS)
         {
             fprintf(stderr, "Error: Drm_GetSecureStoreHash returned 0x%lX\n", (long)err);
             return CDMi_S_FALSE;
         }
+#endif
 
         return CDMi_SUCCESS;
     }
@@ -412,7 +454,11 @@ public:
         DRM_RESULT err;
 
         // DRM Platform Initialization
+#ifdef PR_3_3
+        err = Drm_Platform_Initialize(nullptr);
+#else
         err = Drm_Platform_Initialize();
+#endif
         if(DRM_FAILED(err))
         {
             if (m_poAppContext.get() != nullptr) {
-- 
2.7.4

